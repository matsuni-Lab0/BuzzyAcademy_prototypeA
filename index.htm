<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Buzzy Academy – 行レイアウト最適化＋盤面縮小</title>
<style>
  :root{
    --cell:48px; /* ← 盤面のマスをやや小さく */
    --gap:6px; --bg:#0f172a; --panel:#111827; --muted:#9ca3af;
    --red:#ef4444; --blue:#3b82f6; --yellow:#f59e0b; --gray:#6b7280;
    --bar-bg:#1f2937; --btn:#374151; --btn-txt:#e5e7eb; --good:#10b981;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:#e5e7eb;font-family:system-ui,-apple-system,"Segoe UI",Roboto}
  #wrap{max-width:560px;margin:16px auto;padding:12px}
  h1{font-size:18px;margin:0 0 10px; display:flex; justify-content:space-between; align-items:center;}
  .debug-btn{padding:8px 10px;border-radius:8px;border:1px solid #4b5563;background:#0ea5e9;color:#083344;cursor:pointer}

  /* 時間バー */
  .legend{display:flex;align-items:center;gap:8px;color:var(--muted);font-size:12px;margin-top:4px}
  .bar{height:10px;background:var(--bar-bg);border-radius:8px;overflow:hidden;position:relative}
  .fill{height:100%;width:0%;transition:width .25s}
  .cap{position:absolute;right:6px;top:-18px;font-size:11px;color:var(--muted)}

  /* 敵情報 */
  .enemy-top{display:grid;grid-template-columns:1fr 1fr 1fr;align-items:center;gap:8px;margin-top:10px}
  .e-col{display:flex;align-items:center;gap:8px;justify-content:flex-start}
  .e-mid{justify-content:center;font-weight:700}
  .e-right{justify-content:flex-end}
  .attr-dot{width:12px;height:12px;border-radius:3px;display:inline-block}
  .enemy-img-wrap{display:flex;justify-content:center;align-items:center;margin-top:8px}
  .enemy-img{
    width:100%; max-width:440px; height:auto; max-height:110px;
    object-fit:contain; border-radius:12px; background:#0b1222; border:1px solid #1f2937;
    display:block; padding:8px;
  }
  .hpbar{height:10px;background:#334155;border-radius:8px;overflow:hidden;position:relative;margin-top:8px}
  .hpfill{height:100%;width:100%;background:var(--good);transition:width .25s}
  .hptext{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:11px;color:#e5e7eb;text-shadow:0 1px 0 #000}

  /* プレイヤー概要 */
  .card{background:var(--panel);border-radius:12px;padding:10px;margin-top:10px}
  .small{font-size:11px;color:var(--muted)}

  /* EN行（1行完結レイアウト）：左=技名+威力, 中=バー(伸縮), 右=ボタン */
  .row{
    display:grid;
    grid-template-columns: auto 1fr auto; /* ← 3カラムで必ず1行に収める */
    gap:10px; align-items:center; margin-top:10px;
    min-height:34px;
  }
  .skillinfo{
    font-size:13px;color:#e5e7eb;display:flex;align-items:center;gap:8px;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis; /* 長い名前は…で省略 */
    max-width: 45vw; /* 左が広がり過ぎないように上限 */
  }
  .dot{width:12px;height:12px;border-radius:3px;display:inline-block;flex:0 0 auto}
  .ready{ font-size:11px; color:#fff; background:#16a34a; padding:2px 6px; border-radius:999px; margin-left:6px; display:none; flex:0 0 auto }

  /* 中央のバーは行内でフル伸長 */
  .bar.en{ width:100%; height:10px; }
  .filled{outline:2px solid #fff; outline-offset:-2px; box-shadow:0 0 10px 2px rgba(255,255,255,.5)}

  .btn{ padding:8px 10px;border-radius:8px;border:1px solid #4b5563;background:var(--btn); color:var(--btn-txt); cursor:pointer; min-width:64px; }
  .btn:disabled{ opacity:.6; cursor:not-allowed; background:#30353c; color:#b7bec7; border-color:#454b55; }

  .hint{font-size:12px;color:var(--muted);margin-top:6px}

  /* 盤面（縮小） */
  #board{
    margin-top:12px;
    width: calc(6*var(--cell) + 5*var(--gap));
    display:grid; grid-template-columns: repeat(6, var(--cell)); gap:var(--gap);
    background:var(--panel); padding:var(--gap); border-radius:12px; position:relative;
  }
  .overlay{
    position:absolute; inset:0; display:none; align-items:center; justify-content:center;
    background:rgba(0,0,0,.55); border-radius:12px; font-size:24px; font-weight:800;
    z-index: 9999; pointer-events: auto;
  }
  .cell{
    width:var(--cell); height:var(--cell); border-radius:50%;
    box-shadow: inset 0 -6px 0 rgba(0,0,0,.18);
    cursor:pointer; position:relative; transition: transform .08s, box-shadow .12s;
  }
  .cell.red{ background:var(--red);}
  .cell.blue{ background:var(--blue);}
  .cell.yellow{ background:var(--yellow);}
  .cell.gray{ background:var(--gray);}
  .cell.selected{
    outline:3px solid #fff; outline-offset:-3px;
    box-shadow: 0 0 10px 2px rgba(255,255,255,.6), inset 0 -6px 0 rgba(0,0,0,.18);
    transform: scale(1.06);
  }
  .shake{ animation:shake .18s linear 1; }
  @keyframes shake{
    0%{ transform: translateX(0) }
    25%{ transform: translateX(-3px) }
    50%{ transform: translateX(3px) }
    75%{ transform: translateX(-2px) }
    100%{ transform: translateX(0) }
  }

  /* さらに狭い画面では盤面を段階的に縮小 */
  @media (max-width: 420px){
    :root{ --cell:44px; }
    .skillinfo{ max-width:42vw; font-size:12px; }
  }
  @media (max-width: 360px){
    :root{ --cell:40px; }
    .skillinfo{ max-width:40vw; }
    .btn{ padding:6px 8px; min-width:56px; }
  }
</style>
</head>
<body>
  <div id="wrap">
    <h1>
      <span>Buzzy Academy – レイアウト最適化</span>
      <button id="btn-reset" class="debug-btn" title="臨時デバッグ用：ゲームを即リセット">リセット</button>
    </h1>

    <!-- 時間バー -->
    <div class="legend">ステージ時間</div>
    <div class="bar" id="time-wrap">
      <div id="time-fill" class="fill" style="background:#10b981; width:100%"></div>
      <span id="time-cap" class="cap"></span>
    </div>

    <!-- 敵情報 -->
    <div class="enemy-top">
      <div class="e-col">
        <span class="attr-dot" id="enemy-attr-dot"></span>
        <span id="enemy-attr-label" class="small"></span>
      </div>
      <div class="e-col e-mid" id="enemy-name">あべこべ</div>
      <div class="e-col e-right">HP: <span id="enemy-hpnum">1000</span></div>
    </div>
    <div class="enemy-img-wrap">
      <img id="enemy-img" class="enemy-img" src="images/char1.png" alt="enemy">
    </div>
    <div class="hpbar"><div id="ehp" class="hpfill"></div><div id="ehptext" class="hptext"></div></div>

    <!-- プレイヤー概要 -->
    <div class="card small">
      <b>プレイヤー：</b> めぐ ／
      赤=パンチ(<span id="pow-red"></span>) ／ 青=キック(<span id="pow-blue"></span>) ／ 黄=つんつん(<span id="pow-yellow"></span>)
    </div>

    <!-- EN：3行（各色1行） -->
    <!-- 赤 -->
    <div class="row">
      <div class="skillinfo">
        <span class="dot" style="background:var(--red)"></span>
        <span><b>パンチ</b>（<span id="rowpow-red"></span>）<span id="badge-red" class="ready">READY</span></span>
      </div>
      <div class="bar en" id="barwrap-red"><div id="bar-red" class="fill" style="background:var(--red)"></div></div>
      <button id="btn-red" class="btn" disabled>発動</button>
    </div>

    <!-- 青 -->
    <div class="row">
      <div class="skillinfo">
        <span class="dot" style="background:var(--blue)"></span>
        <span><b>キック</b>（<span id="rowpow-blue"></span>）<span id="badge-blue" class="ready">READY</span></span>
      </div>
      <div class="bar en" id="barwrap-blue"><div id="bar-blue" class="fill" style="background:var(--blue)"></div></div>
      <button id="btn-blue" class="btn" disabled>発動</button>
    </div>

    <!-- 黄 -->
    <div class="row">
      <div class="skillinfo">
        <span class="dot" style="background:var(--yellow)"></span>
        <span><b>つんつん</b>（<span id="rowpow-yellow"></span>）<span id="badge-yellow" class="ready">READY</span></span>
      </div>
      <div class="bar en" id="barwrap-yellow"><div id="bar-yellow" class="fill" style="background:var(--yellow)"></div></div>
      <button id="btn-yellow" class="btn" disabled>発動</button>
    </div>

    <div class="hint">・各色は1行表示（技名＋威力／バー／発動ボタン）。盤面は小さめ。READY時のみ発動可。</div>

    <!-- 盤面 -->
    <div id="board"><div id="overlay" class="overlay">TIME UP!</div></div>
  </div>

<script>
/* ====== 基本・時間 ====== */
const ROWS=6, COLS=6;
const ID = { RED:0, BLUE:1, YELLOW:2, GRAY:3 };
const NAME_BY_ID = { 0:"RED", 1:"BLUE", 2:"YELLOW", 3:"GRAY" };
const CLASS_BY_ID = { 0:"red", 1:"blue", 2:"yellow", 3:"gray" };

const TIME_LIMIT_SECONDS = 60;
let timeLeft = TIME_LIMIT_SECONDS, timer=null, gameOver=false;
function startTimer(){ stopTimer(); timer=setInterval(()=>{ if(gameOver) return; if(timeLeft>0){ timeLeft--; updateTimeBar(); if(timeLeft===0) onGameOver(); } },1000); }
function stopTimer(){ if(timer){ clearInterval(timer); timer=null; } }
function updateTimeBar(){ const pct=(timeLeft/TIME_LIMIT_SECONDS*100).toFixed(0)+'%'; document.getElementById('time-fill').style.width=pct; document.getElementById('time-cap').textContent=`残り: ${timeLeft}s / ${TIME_LIMIT_SECONDS}s`; }

/* ====== 敵・プレイヤー・RPS倍率 ====== */
const ATTR_LABEL = { RED:"赤 (グー)", BLUE:"青 (チョキ)", YELLOW:"黄 (パー)" };
const enemy = { name:"あべこべ", attr:"RED", maxHP:1000, hp:1000, imgSrc:"images/char1.png" };
const player = { name:"めぐ", skills:{ RED:{name:"パンチ",power:50}, BLUE:{name:"キック",power:100}, YELLOW:{name:"つんつん",power:150} } };
const RPS_RATE = { win:1.2, draw:1.0, lose:0.7 };
const beats=(a,b)=> (a==="RED"&&b==="BLUE")||(a==="BLUE"&&b==="YELLOW")||(a==="YELLOW"&&b==="RED");
const rpsMul=(enemyAttr, skillColor)=> enemyAttr===skillColor? RPS_RATE.draw : (beats(skillColor, enemyAttr)? RPS_RATE.win : RPS_RATE.lose);

function renderEnemyHeader(){
  document.getElementById('enemy-name').textContent=enemy.name;
  document.getElementById('enemy-hpnum').textContent=enemy.hp;
  document.getElementById('enemy-attr-dot').style.background=(enemy.attr==="RED"?"var(--red)":enemy.attr==="BLUE"?"var(--blue)":"var(--yellow)");
  document.getElementById('enemy-attr-label').textContent=ATTR_LABEL[enemy.attr];
  document.getElementById('enemy-img').src = enemy.imgSrc;
}
function updateEnemyHPBar(){
  const pct=(enemy.hp/enemy.maxHP*100).toFixed(0)+'%';
  document.getElementById('ehp').style.width=pct;
  document.getElementById('ehptext').textContent=`${enemy.hp}/${enemy.maxHP}`;
  document.getElementById('enemy-hpnum').textContent=enemy.hp;
}
function renderPlayerSkills(){
  document.getElementById('pow-red').textContent=player.skills.RED.power;
  document.getElementById('pow-blue').textContent=player.skills.BLUE.power;
  document.getElementById('pow-yellow').textContent=player.skills.YELLOW.power;
  document.getElementById('rowpow-red').textContent=player.skills.RED.power;
  document.getElementById('rowpow-blue').textContent=player.skills.BLUE.power;
  document.getElementById('rowpow-yellow').textContent=player.skills.YELLOW.power;
}

/* ====== EN関連 ====== */
const ctx = { characterId:"buzzy0006", stageId:"stg-1-1", enemyId:"goo-boss", level:7, itemTags:new Set(["ring_en_boost"]) };
const baseEnTarget = { RED:30, BLUE:30, YELLOW:30 };
function getRequiredEN(colorName){ return baseEnTarget[colorName]; }
const baseGainMult={3:1.0,4:1.5,5:2.0}; const gainChain=(chain)=>1+Math.min(chain-1,4)*0.05;
function getGainAmount(colorName, matchedCount, chain=1){
  if(colorName==="GRAY")return 0;
  const base=matchedCount*(matchedCount>=5?baseGainMult[5]:(baseGainMult[matchedCount]||1.0));
  return Math.max(0, Math.round(base*gainChain(chain)));
}

/* ====== 盤面・状態 ====== */
let grid=[], firstPick=null, en={RED:0,BLUE:0,YELLOW:0}, busy=false;
const board=document.getElementById('board');

function initBoard(){
  grid=Array.from({length:ROWS},()=>Array(COLS).fill(0));
  for(let r=0;r<ROWS;r++){ for(let c=0;c<COLS;c++){
    let color; do{ color=randColor(); }while(causesImmediateMatch(r,c,color)); grid[r][c]=color;
  } }
}
function renderAll(){
  board.innerHTML='';
  const ov=document.createElement('div'); ov.id='overlay'; ov.className='overlay'; ov.textContent='TIME UP!'; board.appendChild(ov);
  for(let r=0;r<ROWS;r++){ for(let c=0;c<COLS;c++){
    const div=document.createElement('div');
    div.className='cell '+CLASS_BY_ID[grid[r][c]];
    div.dataset.r=r; div.dataset.c=c;
    div.addEventListener('click', onCellClick, {passive:true});
    board.appendChild(div);
  } }
}
function resetGame(){
  enemy.hp=enemy.maxHP; gameOver=false; busy=false; firstPick=null; en={RED:0,BLUE:0,YELLOW:0};
  timeLeft=TIME_LIMIT_SECONDS; updateTimeBar();
  renderEnemyHeader(); updateEnemyHPBar(); initBoard(); renderAll(); updateBars();
  hideOverlay(); startTimer();
}

/* ====== 入力・消去 ====== */
function onCellClick(e){
  if(busy||gameOver)return;
  const r=+e.currentTarget.dataset.r, c=+e.currentTarget.dataset.c;
  if(!firstPick){ firstPick={r,c}; highlight(r,c,true); return; }
  if(firstPick.r===r && firstPick.c===c){ highlight(r,c,false); firstPick=null; return; }
  const dr=Math.abs(firstPick.r-r), dc=Math.abs(firstPick.c-c);
  if(dr+dc!==1){ e.currentTarget.classList.add('shake'); setTimeout(()=>e.currentTarget.classList.remove('shake'),220); return; }
  const r1=firstPick.r,c1=firstPick.c,r2=r,c2=c; highlight(r1,c1,false); firstPick=null; trySwap(r1,c1,r2,c2);
}
function highlight(r,c,on){ const idx=r*COLS+c, el=board.children[idx+1]; if(!el)return; if(on)el.classList.add('selected'); else el.classList.remove('selected'); }
function trySwap(r1,c1,r2,c2){
  busy=true; swapInData(r1,c1,r2,c2); renderAll(); const matches=findMatches();
  if(matches.set.size===0){ swapInData(r1,c1,r2,c2); renderAll(); busy=false; }
  else{ resolveBoard(matches,1).then(()=>{ busy=false; }); }
}
function swapInData(r1,c1,r2,c2){ const t=grid[r1][c1]; grid[r1][c1]=grid[r2][c2]; grid[r2][c2]=t; }
function findMatches(){
  const toClear=new Set();
  for(let r=0;r<ROWS;r++){ let run=grid[r][0], s=0; for(let c=1;c<=COLS;c++){ const col=(c<COLS)?grid[r][c]:-1; if(col!==run){ const len=c-s; if(len>=3){ for(let k=s;k<c;k++) toClear.add(`${r},${k}`);} run=col; s=c; } } }
  for(let c=0;c<COLS;c++){ let run=grid[0][c], s=0; for(let r=1;r<=ROWS;r++){ const col=(r<ROWS)?grid[r][c]:-1; if(col!==run){ const len=r-s; if(len>=3){ for(let k=s;k<r;k++) toClear.add(`${k},${c}`);} run=col; s=r; } } }
  const groups={}; for(const key of toClear){ const [r,c]=key.split(',').map(Number); const colId=grid[r][c]; const name=NAME_BY_ID[colId]; groups[name]=(groups[name]||0)+1; }
  return { set:toClear, groups };
}
async function resolveBoard(matches,chain){
  applyEN(matches.groups,chain);
  for(const key of matches.set){ const [r,c]=key.split(',').map(Number); grid[r][c]=null; }
  renderAll(); collapse(); refill(); renderAll();
  const next=findMatches(); if(next.set.size>0){ await sleep(120); return resolveBoard(next,chain+1); }
}
function applyEN(groups,chain){
  for(const colorName in groups){
    const count=groups[colorName];
    const add=getGainAmount(colorName,count,chain);
    if(colorName in en){ const need=getRequiredEN(colorName); en[colorName]=Math.min(need,en[colorName]+add); }
  }
  updateBars();
}
function collapse(){ for(let c=0;c<COLS;c++){ let w=ROWS-1; for(let r=ROWS-1;r>=0;r--){ if(grid[r][c]!==null){ if(w!==r){ grid[w][c]=grid[r][c]; grid[r][c]=null; } w--; } } } }
function refill(){ for(let c=0;c<COLS;c++){ for(let r=0;r<ROWS;r++){ if(grid[r][c]===null){ grid[r][c]=randColor(); } } } }
function randColor(){ return Math.floor(Math.random()*4); }
function causesImmediateMatch(r,c,color){ if(c>=2&&grid[r][c-1]===color&&grid[r][c-2]===color)return true; if(r>=2&&grid[r-1][c]===color&&grid[r-2][c]===color)return true; return false; }

/* ====== ENバー・READY・ボタン ====== */
function updateBars(){
  const needR=getRequiredEN("RED"), needB=getRequiredEN("BLUE"), needY=getRequiredEN("YELLOW");
  const pct=(cur,need)=> Math.max(0,Math.min(100,(cur/need*100))).toFixed(0)+'%';
  document.getElementById('bar-red').style.width=pct(en.RED,needR);
  document.getElementById('bar-blue').style.width=pct(en.BLUE,needB);
  document.getElementById('bar-yellow').style.width=pct(en.YELLOW,needY);

  const rReady=en.RED>=needR, bReady=en.BLUE>=needB, yReady=en.YELLOW>=needY;
  toggleReady('red', rReady); toggleReady('blue', bReady); toggleReady('yellow', yReady);
  setButtonEnabled('red', rReady && !gameOver);
  setButtonEnabled('blue', bReady && !gameOver);
  setButtonEnabled('yellow', yReady && !gameOver);
}
function toggleReady(colorKey,on){ const badge=document.getElementById(`badge-${colorKey}`); const wrap=document.getElementById(`barwrap-${colorKey}`); badge.style.display=on?'inline-block':'none'; wrap.classList.toggle('filled',on); }
function setButtonEnabled(colorKey,on){ const btn=document.getElementById(`btn-${colorKey}`); btn.disabled=!on; }

/* ====== 発動（威力×RPS倍率） ====== */
document.getElementById('btn-red').addEventListener('click', ()=> useSkill("RED"));
document.getElementById('btn-blue').addEventListener('click', ()=> useSkill("BLUE"));
document.getElementById('btn-yellow').addEventListener('click', ()=> useSkill("YELLOW"));
function useSkill(color){
  if(gameOver) return;
  const need=getRequiredEN(color); if(en[color]<need) return;
  const power=player.skills[color].power;
  const mult=rpsMul(enemy.attr,color);
  const dmg=Math.max(1,Math.round(power*mult));
  enemy.hp=Math.max(0,enemy.hp-dmg); updateEnemyHPBar();
  en[color]=0; updateBars();
  if(enemy.hp===0){ stopTimer(); showOverlay("VICTORY!"); gameOver=true; }
}

/* ====== ゲームオーバー＆リセット ====== */
function onGameOver(){ gameOver=true; showOverlay("TIME UP!"); setButtonEnabled('red',false); setButtonEnabled('blue',false); setButtonEnabled('yellow',false); }
function showOverlay(text){ const o=document.getElementById('overlay'); o.textContent=text; o.style.display='flex'; }
function hideOverlay(){ document.getElementById('overlay').style.display='none'; }
document.getElementById('btn-reset').addEventListener('click', resetGame);

/* ====== 小物・起動 ====== */
function sleep(ms){ return new Promise(res=>setTimeout(res,ms)); }
(function boot(){
  renderEnemyHeader(); updateEnemyHPBar();
  document.getElementById('pow-red').textContent=player.skills.RED.power;
  document.getElementById('pow-blue').textContent=player.skills.BLUE.power;
  document.getElementById('pow-yellow').textContent=player.skills.YELLOW.power;
  renderPlayerSkills();
  initBoard(); renderAll();
  updateBars(); updateTimeBar();
  startTimer();
})();
</script>
</body>
</html>
