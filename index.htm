<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Buzzy Academy – 6×6 三消し（戦闘ステータス＋ダメージ計算付き）</title>
<style>
  :root{
    --cell:56px; --gap:6px; --bg:#0f172a; --panel:#111827; --muted:#9ca3af;
    --red:#ef4444; --blue:#3b82f6; --yellow:#f59e0b; --gray:#6b7280;
    --bar-bg:#1f2937; --btn:#374151; --btn-txt:#e5e7eb;
    --good:#10b981; --crit:#f43f5e;
  }
  body{margin:0;background:var(--bg);color:#e5e7eb;font-family:system-ui,-apple-system,"Segoe UI",Roboto}
  #wrap{max-width:560px;margin:16px auto;padding:12px}
  h1{font-size:18px;margin:0 0 10px; display:flex; justify-content:space-between; align-items:center;}
  .debug-btn{padding:8px 10px;border-radius:8px;border:1px solid #4b5563;background:#0ea5e9;color:#083344;cursor:pointer}

  /* 単一の時間バー */
  .legend{display:flex;align-items:center;gap:8px;color:var(--muted);font-size:12px;margin-top:4px}
  .bar{height:12px;background:var(--bar-bg);border-radius:8px;overflow:hidden;position:relative}
  .fill{height:100%;width:0%;transition:width .25s}
  .cap{position:absolute;right:6px;top:-18px;font-size:11px;color:var(--muted)}

  /* ステータス */
  .hud{display:grid;grid-template-columns:1fr;gap:8px;margin-top:10px}
  .card{background:var(--panel);border-radius:12px;padding:10px}
  .hp-row{display:grid;grid-template-columns:64px 1fr;gap:8px;align-items:center}
  .name{font-size:12px;color:#cbd5e1}
  .hpbar{height:12px;background:#334155;border-radius:8px;overflow:hidden;position:relative}
  .hpfill{height:100%;width:100%;background:var(--good);transition:width .25s}
  .hptext{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:11px;color:#e5e7eb;text-shadow:0 1px 0 #000}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:6px}
  .stat{font-size:12px;color:#cbd5e1}
  .small{font-size:11px;color:var(--muted)}
  .log{font-size:12px;color:#e5e7eb;max-height:90px;overflow:auto}
  .log b{color:#eab308}
  .crit{color:var(--crit);font-weight:700}

  /* EN＆ボタン */
  .row{display:grid;grid-template-columns:1fr auto;align-items:center;gap:8px;margin-top:12px}
  .dot{width:12px;height:12px;border-radius:3px;display:inline-block}
  .ready{ font-size:11px; color:#fff; background:#16a34a; padding:2px 6px; border-radius:999px; margin-left:6px; display:none;}
  .filled{outline:2px solid #fff; outline-offset:-2px; box-shadow:0 0 10px 2px rgba(255,255,255,.5)}
  .btn{ padding:8px 10px;border-radius:8px;border:1px solid #4b5563;background:var(--btn); color:var(--btn-txt); cursor:pointer; min-width:64px; }
  .btn:disabled{ opacity:.6; cursor:not-allowed; background:#30353c; color:#b7bec7; border-color:#454b55; }
  .hint{font-size:12px;color:var(--muted);margin-top:6px}

  /* 盤面 */
  #board{
    margin-top:12px;
    width: calc(6*var(--cell) + 5*var(--gap));
    display:grid; grid-template-columns: repeat(6, var(--cell)); gap:var(--gap);
    background:var(--panel); padding:var(--gap); border-radius:12px; position:relative;
  }
  .overlay{
    position:absolute; inset:0; display:none; align-items:center; justify-content:center;
    background:rgba(0,0,0,.55); border-radius:12px; font-size:24px; font-weight:800;
    z-index: 9999; pointer-events: auto;
  }
  .cell{
    width:var(--cell); height:var(--cell); border-radius:50%;
    box-shadow: inset 0 -6px 0 rgba(0,0,0,.18);
    cursor:pointer; position:relative; transition: transform .08s, box-shadow .12s;
  }
  .cell.red{ background:var(--red);}
  .cell.blue{ background:var(--blue);}
  .cell.yellow{ background:var(--yellow);}
  .cell.gray{ background:var(--gray);}
  .cell.selected{
    outline:3px solid #fff; outline-offset:-3px;
    box-shadow: 0 0 10px 2px rgba(255,255,255,.6), inset 0 -6px 0 rgba(0,0,0,.18);
    transform: scale(1.06);
  }
  .shake{ animation:shake .18s linear 1; }
  @keyframes shake{
    0%{ transform: translateX(0) }
    25%{ transform: translateX(-3px) }
    50%{ transform: translateX(3px) }
    75%{ transform: translateX(-2px) }
    100%{ transform: translateX(0) }
  }
</style>
</head>
<body>
  <div id="wrap">
    <h1>
      <span>Buzzy Academy – 戦闘付き雛形</span>
      <button id="btn-reset" class="debug-btn" title="臨時デバッグ用：ゲームを即リセット">リセット</button>
    </h1>

    <!-- 時間バー -->
    <div class="legend">ステージ時間</div>
    <div class="bar" id="time-wrap">
      <div id="time-fill" class="fill" style="background:#10b981; width:100%"></div>
      <span id="time-cap" class="cap"></span>
    </div>

    <!-- ステータス（プレイヤー＆敵） -->
    <div class="hud">
      <div class="card">
        <div class="hp-row">
          <div class="name">プレイヤー</div>
          <div class="hpbar"><div id="php" class="hpfill"></div><div id="phptext" class="hptext"></div></div>
        </div>
        <div class="grid2">
          <div class="stat">ATK: <span id="patk"></span> / DEF: <span id="pdef"></span></div>
          <div class="stat">CRIT: <span id="pcrit"></span> / C.DMG: <span id="pcdmg"></span></div>
        </div>
      </div>
      <div class="card">
        <div class="hp-row">
          <div class="name">敵</div>
          <div class="hpbar"><div id="ehp" class="hpfill"></div><div id="ehptext" class="hptext"></div></div>
        </div>
        <div class="grid2">
          <div class="stat">DEF: <span id="edef"></span></div>
          <div class="stat small">耐性（赤/青/黄）: <span id="eres"></span></div>
        </div>
        <div class="small log" id="combat-log"></div>
      </div>
    </div>

    <!-- ENバー＋発動（READY時のみ） -->
    <div class="row">
      <div class="legend"><span class="dot" style="background:var(--red)"></span>赤=グー EN <span id="badge-red" class="ready">READY</span></div>
      <button id="btn-red" class="btn" disabled>発動</button>
    </div>
    <div class="bar" id="barwrap-red"><div id="bar-red" class="fill" style="background:var(--red)"></div><span id="cap-red" class="cap"></span></div>

    <div class="row">
      <div class="legend"><span class="dot" style="background:var(--blue)"></span>青=チョキ EN <span id="badge-blue" class="ready">READY</span></div>
      <button id="btn-blue" class="btn" disabled>発動</button>
    </div>
    <div class="bar" id="barwrap-blue"><div id="bar-blue" class="fill" style="background:var(--blue)"></div><span id="cap-blue" class="cap"></span></div>

    <div class="row">
      <div class="legend"><span class="dot" style="background:var(--yellow)"></span>黄=パー EN <span id="badge-yellow" class="ready">READY</span></div>
      <button id="btn-yellow" class="btn" disabled>発動</button>
    </div>
    <div class="bar" id="barwrap-yellow"><div id="bar-yellow" class="fill" style="background:var(--yellow)"></div><span id="cap-yellow" class="cap"></span></div>

    <div class="hint">・隣接2タップで入替 → 縦/横3+で消去 → 落下→補充→連鎖／灰はEN加算なし<br>
    ・READY時のみ発動可：色ごとのスキルで敵へダメージ、ENはリセット</div>

    <div id="board"><div id="overlay" class="overlay">TIME UP!</div></div>
  </div>

<script>
/* =======================
   基本設定
======================= */
const ROWS=6, COLS=6;
const ID = { RED:0, BLUE:1, YELLOW:2, GRAY:3 };
const NAME_BY_ID = { 0:"RED", 1:"BLUE", 2:"YELLOW", 3:"GRAY" };
const CLASS_BY_ID = { 0:"red", 1:"blue", 2:"yellow", 3:"gray" };

/* =======================
   ステータス定義
======================= */
const player = {
  level: 5,
  maxHP: 300, hp: 300,
  atk: 60, def: 12,
  critRate: 0.15,      // 15%
  critDamage: 1.6,     // x1.6
};
const enemy = {
  name: "Goo Golem",
  maxHP: 500, hp: 500,
  def: 10,
  res: { RED: 0.10, BLUE: 0.00, YELLOW: 0.20 }, // 10%/0%/20% 軽減
};
const skillPower = { RED: 1.10, BLUE: 1.00, YELLOW: 0.90 }; // 色ごとの基礎威力

/* =======================
   単一の時間バー（減少式）
======================= */
const TIME_LIMIT_SECONDS = 60;
let timeLeft = TIME_LIMIT_SECONDS;
let timer = null;
let gameOver = false;

function startTimer(){
  stopTimer();
  timer = setInterval(()=>{
    if(gameOver) return;
    if(timeLeft>0){
      timeLeft--;
      updateTimeBar();
      if(timeLeft===0){ onGameOver(); }
    }
  }, 1000);
}
function stopTimer(){ if(timer){ clearInterval(timer); timer=null; } }
function updateTimeBar(){
  const pct = (timeLeft / TIME_LIMIT_SECONDS * 100).toFixed(0) + '%';
  document.getElementById('time-fill').style.width = pct;
  document.getElementById('time-cap').textContent = `残り: ${timeLeft}s / ${TIME_LIMIT_SECONDS}s`;
}
function resetStageTimer(){ timeLeft = TIME_LIMIT_SECONDS; updateTimeBar(); }

/* =======================
   拡張フック（必要EN/加算量）
======================= */
const ctx = { characterId:"buzzy0006", stageId:"stg-1-1", enemyId:"goo-boss", level:7, itemTags: new Set(["ring_en_boost"]) };
const baseEnTarget = { RED:30, BLUE:30, YELLOW:30 };
const modifiers = {
  byCharacter: { buzzy0006: { RED: 0.90 } },
  byStage:     { "stg-1-1": { ALL: 1.00 }, "stg-2-1": { ALL: 1.20 } },
  byEnemy:     { "goo-boss": { RED: 1.25 } },
  byLevel:     (lvl)=> (lvl>=10? 1.10 : 1.00),
  byItems:     { ring_en_boost: { ALL: 0.90 } }
};
function getRequiredEN(colorName, ctx){
  let need = baseEnTarget[colorName], mul = 1.0;
  const ch = modifiers.byCharacter[ctx.characterId] || {};
  const st = modifiers.byStage[ctx.stageId] || {};
  const enm= modifiers.byEnemy[ctx.enemyId] || {};
  mul *= (ch[colorName] ?? ch.ALL ?? 1.0);
  mul *= (st[colorName] ?? st.ALL ?? 1.0);
  mul *= (enm[colorName] ?? enm.ALL ?? 1.0);
  mul *= (modifiers.byLevel?.(ctx.level) ?? 1.0);
  for(const tag of ctx.itemTags){ const it=modifiers.byItems[tag]; if(it) mul *= (it[colorName] ?? it.ALL ?? 1.0); }
  return Math.max(5, Math.round(need * mul));
}
const baseGainMult = { 3:1.0, 4:1.5, 5:2.0 };
const gainMods = {
  byCharacter: { buzzy0006: { ALL: 1.00, YELLOW: 1.20 } },
  byStage:     { "stg-2-1": { ALL: 0.90 } },
  byChain:     (chain)=> (1 + Math.min(chain-1, 4)*0.05),
  byItems:     { orb_red_up: { RED: 1.15 } },
};
function getGainAmount(colorName, matchedCount, ctx, chain=1){
  if(colorName==="GRAY") return 0;
  const base = matchedCount * (matchedCount>=5 ? baseGainMult[5] : (baseGainMult[matchedCount]||1.0));
  let mul = 1.0;
  const ch = gainMods.byCharacter[ctx.characterId] || {};
  const st = gainMods.byStage[ctx.stageId] || {};
  mul *= (ch[colorName] ?? ch.ALL ?? 1.0);
  mul *= (st[colorName] ?? st.ALL ?? 1.0);
  mul *= (gainMods.byChain?.(chain) ?? 1.0);
  for(const tag of ctx.itemTags){ const it=gainMods.byItems[tag]; if(it) mul *= (it[colorName] ?? it.ALL ?? 1.0); }
  return Math.max(0, Math.round(base * mul));
}

/* =======================
   ダメージ計算
======================= */
function calcDamage({attacker, defender, element="RED", power=1.0, chain=1}){
  // 元攻撃
  let atk = attacker.atk;
  // 属性耐性　例: res=0.2 → 20%カット
  const res = defender.res?.[element] ?? 0.0;
  const elemMod = Math.max(0, 1 - res);

  // 連鎖補正（UI側と同一ロジック）
  const chainMod = 1 + Math.min(chain-1, 4) * 0.05;

  // 乱数 ±5%
  const variance = 0.95 + Math.random()*0.10;

  // クリティカル
  const isCrit = Math.random() < (attacker.critRate ?? 0);
  const critMod = isCrit ? (attacker.critDamage ?? 1.5) : 1.0;

  // 物理軽減（簡易）：最終からDEFを引く
  const raw = atk * power * elemMod * chainMod * variance;
  const afterDef = Math.max(1, Math.round(raw - (defender.def ?? 0)));
  const final = Math.max(1, Math.round(afterDef * critMod));

  return {
    final,
    isCrit,
    breakdown: { atk, power, elemMod, chainMod, variance:+variance.toFixed(2), critMod, def:defender.def ?? 0, res }
  };
}

/* =======================
   状態
======================= */
let grid = [];
let firstPick = null;
let en = { RED:0, BLUE:0, YELLOW:0 };
let busy = false;

const board = document.getElementById('board');
const overlay = document.getElementById('overlay');

/* =======================
   初期化・リセット
======================= */
function initBoard(){
  grid = Array.from({length:ROWS}, ()=>Array(COLS).fill(0));
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      let color;
      do{ color = randColor(); }while(causesImmediateMatch(r,c,color));
      grid[r][c]=color;
    }
  }
}
function renderAll(){
  board.innerHTML='';
  // overlay を入れ直す（最前面）
  const ov = document.createElement('div');
  ov.id='overlay'; ov.className='overlay'; ov.textContent='TIME UP!';
  board.appendChild(ov);
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const div=document.createElement('div');
      div.className='cell '+CLASS_BY_ID[grid[r][c]];
      div.dataset.r=r; div.dataset.c=c;
      div.addEventListener('click', onCellClick, {passive:true});
      board.appendChild(div);
    }
  }
}
function resetGame(){
  // ステータス
  player.hp = player.maxHP;
  enemy.hp = enemy.maxHP;

  // 状態リセット
  gameOver = false;
  busy = false;
  firstPick = null;
  en = { RED:0, BLUE:0, YELLOW:0 };
  timeLeft = TIME_LIMIT_SECONDS;
  updateTimeBar();

  // 盤面再生成
  initBoard();
  renderAll();
  updateBars();
  updateHUD();

  // 入力許可＆タイマー再開・オーバーレイ非表示
  setInputEnabled(true);
  hideOverlay();
  startTimer();

  logClear();
}

/* =======================
   盤面生成補助
======================= */
function randColor(){ return Math.floor(Math.random()*4); }
function causesImmediateMatch(r,c,color){
  if(c>=2 && grid[r][c-1]===color && grid[r][c-2]===color) return true;
  if(r>=2 && grid[r-1][c]===color && grid[r-2][c]===color) return true;
  return false;
}

/* =======================
   入力・スワップ
======================= */
function onCellClick(e){
  if(busy || gameOver) return;
  const r=+e.currentTarget.dataset.r, c=+e.currentTarget.dataset.c;
  if(!firstPick){ firstPick={r,c}; highlight(r,c,true); return; }
  if(firstPick.r===r && firstPick.c===c){ highlight(r,c,false); firstPick=null; return; }
  const dr=Math.abs(firstPick.r-r), dc=Math.abs(firstPick.c-c);
  if(dr+dc!==1){ flashShake(e.currentTarget); return; }
  const r1=firstPick.r, c1=firstPick.c, r2=r, c2=c;
  highlight(r1,c1,false); firstPick=null;
  trySwap(r1,c1,r2,c2);
}
function highlight(r,c,on){
  const idx=r*COLS+c, el = board.children[idx+1]; // +1 は overlay 分
  if(!el) return;
  if(on) el.classList.add('selected'); else el.classList.remove('selected');
}
function flashShake(el){ el.classList.add('shake'); setTimeout(()=>el.classList.remove('shake'), 220); }

function trySwap(r1,c1,r2,c2){
  busy=true;
  swapInData(r1,c1,r2,c2); renderAll();
  const matches=findMatches();
  if(matches.set.size===0){
    swapInData(r1,c1,r2,c2); renderAll(); busy=false;
  }else{
    resolveBoard(matches,1).then(()=>{ busy=false; });
  }
}
function swapInData(r1,c1,r2,c2){ const t=grid[r1][c1]; grid[r1][c1]=grid[r2][c2]; grid[r2][c2]=t; }

/* =======================
   マッチ探索（縦・横）
======================= */
function findMatches(){
  const toClear=new Set();
  // 横
  for(let r=0;r<ROWS;r++){
    let runColor=grid[r][0], runStart=0;
    for(let c=1;c<=COLS;c++){
      const color=(c<COLS)? grid[r][c] : -1;
      if(color!==runColor){
        const len=c-runStart;
        if(len>=3){ for(let k=runStart;k<c;k++) toClear.add(`${r},${k}`); }
        runColor=color; runStart=c;
      }
    }
  }
  // 縦
  for(let c=0;c<COLS;c++){
    let runColor=grid[0][c], runStart=0;
    for(let r=1;r<=ROWS;r++){
      const color=(r<ROWS)? grid[r][c] : -1;
      if(color!==runColor){
        const len=r-runStart;
        if(len>=3){ for(let k=runStart;k<r;k++) toClear.add(`${k},${c}`); }
        runColor=color; runStart=r;
      }
    }
  }
  // 色別カウント
  const groups={};
  for(const key of toClear){
    const [r,c]=key.split(',').map(Number);
    const colId=grid[r][c];
    const name=NAME_BY_ID[colId];
    groups[name]=(groups[name]||0)+1;
  }
  return { set:toClear, groups };
}

/* =======================
   解決（消去→落下→補充→連鎖）
======================= */
async function resolveBoard(matches, chain){
  applyEN(matches.groups, chain);
  for(const key of matches.set){ const [r,c]=key.split(',').map(Number); grid[r][c]=null; }
  renderAll(); collapse(); refill(); renderAll();
  const next=findMatches();
  if(next.set.size>0){ await sleep(120); return resolveBoard(next, chain+1); }
}
function applyEN(groups, chain){
  for(const colorName in groups){
    const count=groups[colorName];
    const add=getGainAmount(colorName, count, ctx, chain);
    if(colorName in en){
      const need=getRequiredEN(colorName, ctx);
      en[colorName] = Math.min(need, en[colorName]+add);
    }
  }
  updateBars();
}
function collapse(){
  for(let c=0;c<COLS;c++){
    let write=ROWS-1;
    for(let r=ROWS-1;r>=0;r--){
      if(grid[r][c]!==null){
        if(write!==r){ grid[write][c]=grid[r][c]; grid[r][c]=null; }
        write--;
      }
    }
  }
}
function refill(){
  for(let c=0;c<COLS;c++){
    for(let r=0;r<ROWS;r++){
      if(grid[r][c]===null){ grid[r][c]=randColor(); }
    }
  }
}

/* =======================
   UI更新（ENバー・READY・ボタン有効化）
======================= */
function updateBars(){
  const needR=getRequiredEN("RED",ctx), needB=getRequiredEN("BLUE",ctx), needY=getRequiredEN("YELLOW",ctx);
  const pct=(cur,need)=> (cur/need*100).toFixed(0)+'%';
  document.getElementById('bar-red').style.width   = pct(en.RED, needR);
  document.getElementById('bar-blue').style.width  = pct(en.BLUE, needB);
  document.getElementById('bar-yellow').style.width= pct(en.YELLOW, needY);
  document.getElementById('cap-red').textContent    = `目標: ${needR}`;
  document.getElementById('cap-blue').textContent   = `目標: ${needB}`;
  document.getElementById('cap-yellow').textContent = `目標: ${needY}`;

  const rReady = en.RED   >= needR;
  const bReady = en.BLUE  >= needB;
  const yReady = en.YELLOW>= needY;

  toggleReady('red', rReady);
  toggleReady('blue', bReady);
  toggleReady('yellow', yReady);

  setButtonEnabled('red',    rReady && !gameOver);
  setButtonEnabled('blue',   bReady && !gameOver);
  setButtonEnabled('yellow', yReady && !gameOver);
}
function toggleReady(colorKey, on){
  const badge = document.getElementById(`badge-${colorKey}`);
  const wrap  = document.getElementById(`barwrap-${colorKey}`);
  badge.style.display = on ? 'inline-block' : 'none';
  wrap.classList.toggle('filled', on);
}
function setButtonEnabled(colorKey, on){
  const btn = document.getElementById(`btn-${colorKey}`);
  btn.disabled = !on;
}

/* =======================
   発動ボタン（READY時のみ押下可：与ダメ＋ENリセット）
======================= */
document.getElementById('btn-red').addEventListener('click', ()=> useSkill("RED"));
document.getElementById('btn-blue').addEventListener('click', ()=> useSkill("BLUE"));
document.getElementById('btn-yellow').addEventListener('click', ()=> useSkill("YELLOW"));

function useSkill(colorName){
  if(gameOver) return;
  const need = getRequiredEN(colorName, ctx);
  if(en[colorName] < need) return; // 念のため

  // ダメージ計算
  const {final, isCrit, breakdown} = calcDamage({
    attacker: player, defender: enemy,
    element: colorName, power: skillPower[colorName], chain: 1
  });

  enemy.hp = Math.max(0, enemy.hp - final);
  updateHUD();
  log(`${colorName} 発動 → <b>${final}</b> ダメージ${isCrit? ' <span class="crit">CRIT!</span>':''}`);

  // ENリセット
  en[colorName] = 0;
  updateBars();

  if(enemy.hp === 0){
    // とりあえず時間を止め、勝利表示（TIME UPの代わりに）
    stopTimer();
    showOverlay("VICTORY!");
    setInputEnabled(false);
    setButtonEnabled('red', false);
    setButtonEnabled('blue', false);
    setButtonEnabled('yellow', false);
    gameOver = true;
  }
}

/* =======================
   HUD更新・ログ
======================= */
function updateHUD(){
  // プレイヤー
  const phpPct = (player.hp/player.maxHP*100).toFixed(0)+'%';
  document.getElementById('php').style.width = phpPct;
  document.getElementById('phptext').textContent = `${player.hp}/${player.maxHP}`;
  document.getElementById('patk').textContent = player.atk;
  document.getElementById('pdef').textContent = player.def;
  document.getElementById('pcrit').textContent = Math.round(player.critRate*100)+'%';
  document.getElementById('pcdmg').textContent = 'x'+player.critDamage.toFixed(2);

  // 敵
  const ehpPct = (enemy.hp/enemy.maxHP*100).toFixed(0)+'%';
  document.getElementById('ehp').style.width = ehpPct;
  document.getElementById('ehptext').textContent = `${enemy.hp}/${enemy.maxHP}`;
  document.getElementById('edef').textContent = enemy.def;
  document.getElementById('eres').textContent = `${Math.round(enemy.res.RED*100)}% / ${Math.round(enemy.res.BLUE*100)}% / ${Math.round(enemy.res.YELLOW*100)}%`;
}
function log(msg){
  const el=document.getElementById('combat-log');
  const line=document.createElement('div'); line.innerHTML=msg;
  el.prepend(line);
  // 10行程度に抑制
  while(el.childElementCount>10){ el.removeChild(el.lastChild); }
}
function logClear(){ document.getElementById('combat-log').innerHTML=''; }

/* =======================
   ゲームオーバー＆リセット
======================= */
function onGameOver(){
  gameOver = true;
  setInputEnabled(false);
  showOverlay("TIME UP!");
  setButtonEnabled('red', false);
  setButtonEnabled('blue', false);
  setButtonEnabled('yellow', false);
}
function setInputEnabled(on){ busy = !on; }
function showOverlay(text){ const o=document.getElementById('overlay'); o.textContent=text; o.style.display='flex'; }
function hideOverlay(){ document.getElementById('overlay').style.display='none'; }

document.getElementById('btn-reset').addEventListener('click', resetGame);

/* =======================
   小物
======================= */
function sleep(ms){ return new Promise(res=>setTimeout(res,ms)); }

/* =======================
   起動
======================= */
(function boot(){
  initBoard(); renderAll(); updateBars(); updateTimeBar(); updateHUD();
  startTimer();
})();
</script>
</body>
</html>
