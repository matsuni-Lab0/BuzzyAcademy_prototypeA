<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Buzzy Academy – 6×6 三消し（スキルボタン＆時間バー付）</title>
<style>
  :root{
    --cell:56px; --gap:6px; --bg:#0f172a; --panel:#111827; --muted:#9ca3af;
    --red:#ef4444; --blue:#3b82f6; --yellow:#f59e0b; --gray:#6b7280;
    --bar-bg:#1f2937; --btn:#374151; --btn-txt:#e5e7eb; --btn-dis:#6b7280;
  }
  body{margin:0;background:var(--bg);color:#e5e7eb;font-family:system-ui,-apple-system,"Segoe UI",Roboto}
  #wrap{max-width:520px;margin:16px auto;padding:12px}
  h1{font-size:18px;margin:0 0 10px}

  .row{display:grid;grid-template-columns:1fr auto;align-items:center;gap:8px;margin-top:10px}
  .legend{display:flex;align-items:center;gap:8px;color:var(--muted);font-size:12px}
  .dot{width:12px;height:12px;border-radius:3px;display:inline-block}
  .ready{ font-size:11px; color:#fff; background:#16a34a; padding:2px 6px; border-radius:999px; margin-left:6px; display:none;}
  .btn{
    padding:8px 10px;border-radius:8px;border:1px solid #4b5563;background:var(--btn);
    color:var(--btn-txt); cursor:pointer; min-width:64px;
  }
  .btn:disabled{ opacity:.6; cursor:not-allowed; background:#30353c; color:#b7bec7; border-color:#454b55; }

  .stack{display:flex;flex-direction:column;gap:6px}
  .tbar, .bar{height:12px;background:var(--bar-bg);border-radius:8px;overflow:hidden;position:relative}
  .tfill{height:100%;width:100%;background:#10b981; transition: width .25s;} /* 時間バー：減っていく */
  .fill{height:100%;width:0%; transition: width .25s;}
  .cap{position:absolute;right:6px;top:-18px;font-size:11px;color:var(--muted)}
  .filled{outline:2px solid #fff; outline-offset:-2px; box-shadow:0 0 10px 2px rgba(255,255,255,.5)}
  .hint{font-size:12px;color:var(--muted);margin-top:6px}

  #board{
    margin-top:12px;
    width: calc(6*var(--cell) + 5*var(--gap));
    display:grid; grid-template-columns: repeat(6, var(--cell)); gap:var(--gap);
    background:var(--panel); padding:var(--gap); border-radius:12px;
  }
  .cell{
    width:var(--cell); height:var(--cell); border-radius:50%;
    box-shadow: inset 0 -6px 0 rgba(0,0,0,.18);
    cursor:pointer; position:relative; transition: transform .08s, box-shadow .12s;
  }
  .cell.red{ background:var(--red);}
  .cell.blue{ background:var(--blue);}
  .cell.yellow{ background:var(--yellow);}
  .cell.gray{ background:var(--gray);}
  .cell.selected{
    outline:3px solid #fff; outline-offset:-3px;
    box-shadow: 0 0 10px 2px rgba(255,255,255,.6), inset 0 -6px 0 rgba(0,0,0,.18);
    transform: scale(1.06);
  }
  .shake{ animation:shake .18s linear 1; }
  @keyframes shake{
    0%{ transform: translateX(0) }
    25%{ transform: translateX(-3px) }
    50%{ transform: translateX(3px) }
    75%{ transform: translateX(-2px) }
    100%{ transform: translateX(0) }
  }
</style>
</head>
<body>
  <div id="wrap">
    <h1>Buzzy Academy – 色だけ版パズル（スキルボタン＆時間バー付）</h1>

    <!-- RED 行 -->
    <div class="row">
      <div class="legend">
        <span class="dot" style="background:var(--red)"></span>赤=グー EN
        <span id="badge-red" class="ready">READY</span>
      </div>
      <button id="btn-red" class="btn">発動</button>
    </div>
    <div class="stack">
      <div class="tbar"><div id="time-red" class="tfill"></div></div>
      <div class="bar" id="barwrap-red">
        <div id="bar-red" class="fill" style="background:var(--red)"></div>
        <span id="cap-red" class="cap"></span>
      </div>
    </div>

    <!-- BLUE 行 -->
    <div class="row">
      <div class="legend">
        <span class="dot" style="background:var(--blue)"></span>青=チョキ EN
        <span id="badge-blue" class="ready">READY</span>
      </div>
      <button id="btn-blue" class="btn">発動</button>
    </div>
    <div class="stack">
      <div class="tbar"><div id="time-blue" class="tfill"></div></div>
      <div class="bar" id="barwrap-blue">
        <div id="bar-blue" class="fill" style="background:var(--blue)"></div>
        <span id="cap-blue" class="cap"></span>
      </div>
    </div>

    <!-- YELLOW 行 -->
    <div class="row">
      <div class="legend">
        <span class="dot" style="background:var(--yellow)"></span>黄=パー EN
        <span id="badge-yellow" class="ready">READY</span>
      </div>
      <button id="btn-yellow" class="btn">発動</button>
    </div>
    <div class="stack">
      <div class="tbar"><div id="time-yellow" class="tfill"></div></div>
      <div class="bar" id="barwrap-yellow">
        <div id="bar-yellow" class="fill" style="background:var(--yellow)"></div>
        <span id="cap-yellow" class="cap"></span>
      </div>
    </div>

    <div class="hint">・隣接2枚をタップで入替 → 縦/横で3つ以上なら消去 → 落下・補充・連鎖　・灰色はEN加算なし<br>
    ・各行の「発動」ボタンを押すと、その色のENがリセット（前段階仕様）。時間バーは60秒で減少（定数で変更可）。</div>

    <div id="board"></div>
  </div>

<script>
/* =======================
   基本設定＆タイマー設定
======================= */
const ROWS=6, COLS=6;
const ID = { RED:0, BLUE:1, YELLOW:2, GRAY:3 };
const NAME_BY_ID = { 0:"RED", 1:"BLUE", 2:"YELLOW", 3:"GRAY" };
const CLASS_BY_ID = { 0:"red", 1:"blue", 2:"yellow", 3:"gray" };

// ★ ここで時間を変更できます（秒）
const TIME_LIMIT_SECONDS = 60;

// 各色の残り時間（秒）
const timeLeft = { RED: TIME_LIMIT_SECONDS, BLUE: TIME_LIMIT_SECONDS, YELLOW: TIME_LIMIT_SECONDS };
// タイマー間隔
setInterval(()=>{
  for(const k of ["RED","BLUE","YELLOW"]){
    if(timeLeft[k]>0){ timeLeft[k]--; }
  }
  updateTimeBars();
}, 1000);

/* =======================
   拡張フック（必要EN/加算量）
======================= */
const ctx = {
  characterId: "buzzy0006",
  stageId: "stg-1-1",
  enemyId: "goo-boss",
  level: 7,
  itemTags: new Set(["ring_en_boost"])
};

// 必要ENの基準（マスターの方針に合わせて30を初期値に）
const baseEnTarget = { RED:30, BLUE:30, YELLOW:30 };

const modifiers = {
  byCharacter: { buzzy0006: { RED: 0.90 } },
  byStage:     { "stg-1-1": { ALL: 1.00 }, "stg-2-1": { ALL: 1.20 } },
  byEnemy:     { "goo-boss": { RED: 1.25 } },
  byLevel:     (lvl)=> (lvl>=10? 1.10 : 1.00),
  byItems:     { ring_en_boost: { ALL: 0.90 } }
};

function getRequiredEN(colorName, ctx){
  let need = baseEnTarget[colorName];
  let mul = 1.0;
  const ch = modifiers.byCharacter[ctx.characterId] || {};
  const st = modifiers.byStage[ctx.stageId] || {};
  const enm= modifiers.byEnemy[ctx.enemyId] || {};
  mul *= (ch[colorName] ?? ch.ALL ?? 1.0);
  mul *= (st[colorName] ?? st.ALL ?? 1.0);
  mul *= (enm[colorName] ?? enm.ALL ?? 1.0);
  mul *= (modifiers.byLevel?.(ctx.level) ?? 1.0);
  for(const tag of ctx.itemTags){
    const it = modifiers.byItems[tag]; if(it) mul *= (it[colorName] ?? it.ALL ?? 1.0);
  }
  return Math.max(5, Math.round(need * mul));
}

// 加算量
const baseGainMult = { 3:1.0, 4:1.5, 5:2.0 };
const gainMods = {
  byCharacter: { buzzy0006: { ALL: 1.00, YELLOW: 1.20 } },
  byStage:     { "stg-2-1": { ALL: 0.90 } },
  byChain:     (chain)=> (1 + Math.min(chain-1, 4)*0.05),
  byItems:     { orb_red_up: { RED: 1.15 } },
};
function getGainAmount(colorName, matchedCount, ctx, chain=1){
  if(colorName==="GRAY") return 0;
  const base = matchedCount * (matchedCount>=5 ? baseGainMult[5] : (baseGainMult[matchedCount]||1.0));
  let mul = 1.0;
  const ch = gainMods.byCharacter[ctx.characterId] || {};
  const st = gainMods.byStage[ctx.stageId] || {};
  mul *= (ch[colorName] ?? ch.ALL ?? 1.0);
  mul *= (st[colorName] ?? st.ALL ?? 1.0);
  mul *= (gainMods.byChain?.(chain) ?? 1.0);
  for(const tag of ctx.itemTags){
    const it = gainMods.byItems[tag]; if(it) mul *= (it[colorName] ?? it.ALL ?? 1.0);
  }
  return Math.max(0, Math.round(base * mul));
}

/* =======================
   状態
======================= */
let grid = [];
let firstPick = null;
let en = { RED:0, BLUE:0, YELLOW:0 };
let busy = false;

const board = document.getElementById('board');

/* =======================
   盤面生成・描画
======================= */
initBoard();
renderAll();
updateBars();
updateTimeBars();

function initBoard(){
  grid = Array.from({length:ROWS}, ()=>Array(COLS).fill(0));
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      let color;
      do{ color = randColor(); }while(causesImmediateMatch(r,c,color));
      grid[r][c]=color;
    }
  }
}
function randColor(){ return Math.floor(Math.random()*4); } // 0..3
function causesImmediateMatch(r,c,color){
  if(c>=2 && grid[r][c-1]===color && grid[r][c-2]===color) return true;
  if(r>=2 && grid[r-1][c]===color && grid[r-2][c]===color) return true;
  return false;
}
function renderAll(){
  board.innerHTML='';
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const div=document.createElement('div');
      div.className='cell '+CLASS_BY_ID[grid[r][c]];
      div.dataset.r=r; div.dataset.c=c;
      div.addEventListener('click', onCellClick, {passive:true});
      board.appendChild(div);
    }
  }
}

/* =======================
   入力・スワップ
======================= */
function onCellClick(e){
  if(busy) return;
  const r=+e.currentTarget.dataset.r, c=+e.currentTarget.dataset.c;
  if(!firstPick){ firstPick={r,c}; highlight(r,c,true); return; }
  if(firstPick.r===r && firstPick.c===c){ highlight(r,c,false); firstPick=null; return; }
  const dr=Math.abs(firstPick.r-r), dc=Math.abs(firstPick.c-c);
  if(dr+dc!==1){ flashShake(e.currentTarget); return; }
  const r1=firstPick.r, c1=firstPick.c, r2=r, c2=c;
  highlight(r1,c1,false); firstPick=null;
  trySwap(r1,c1,r2,c2);
}
function highlight(r,c,on){
  const idx=r*COLS+c, el = board.children[idx];
  if(!el) return;
  if(on) el.classList.add('selected'); else el.classList.remove('selected');
}
function flashShake(el){ el.classList.add('shake'); setTimeout(()=>el.classList.remove('shake'), 220); }

function trySwap(r1,c1,r2,c2){
  busy=true;
  swapInData(r1,c1,r2,c2);
  renderAll();
  const matches=findMatches();
  if(matches.set.size===0){
    swapInData(r1,c1,r2,c2); renderAll(); busy=false;
  }else{
    resolveBoard(matches,1).then(()=>{ busy=false; });
  }
}
function swapInData(r1,c1,r2,c2){
  const tmp=grid[r1][c1]; grid[r1][c1]=grid[r2][c2]; grid[r2][c2]=tmp;
}

/* =======================
   マッチ探索（縦・横）
======================= */
function findMatches(){
  const toClear=new Set();
  // 横
  for(let r=0;r<ROWS;r++){
    let runColor=grid[r][0], runStart=0;
    for(let c=1;c<=COLS;c++){
      const color=(c<COLS)? grid[r][c] : -1;
      if(color!==runColor){
        const len=c-runStart;
        if(len>=3){ for(let k=runStart;k<c;k++) toClear.add(`${r},${k}`); }
        runColor=color; runStart=c;
      }
    }
  }
  // 縦
  for(let c=0;c<COLS;c++){
    let runColor=grid[0][c], runStart=0;
    for(let r=1;r<=ROWS;r++){
      const color=(r<ROWS)? grid[r][c] : -1;
      if(color!==runColor){
        const len=r-runStart;
        if(len>=3){ for(let k=runStart;k<r;k++) toClear.add(`${k},${c}`); }
        runColor=color; runStart=r;
      }
    }
  }
  // 色別カウント
  const groups={};
  for(const key of toClear){
    const [r,c]=key.split(',').map(Number);
    const colId=grid[r][c];
    const name=NAME_BY_ID[colId];
    groups[name]=(groups[name]||0)+1;
  }
  return { set:toClear, groups };
}

/* =======================
   解決（消去→落下→補充→連鎖）
======================= */
async function resolveBoard(matches, chain){
  applyEN(matches.groups, chain);
  for(const key of matches.set){
    const [r,c]=key.split(',').map(Number); grid[r][c]=null;
  }
  renderAll();
  collapse(); refill(); renderAll();
  const next=findMatches();
  if(next.set.size>0){ await sleep(120); return resolveBoard(next, chain+1); }
}
function applyEN(groups, chain){
  for(const colorName in groups){
    const count=groups[colorName];
    const add=getGainAmount(colorName, count, ctx, chain);
    if(colorName in en){
      const need=getRequiredEN(colorName, ctx);
      en[colorName] = Math.min(need, en[colorName]+add);
    }
  }
  updateBars();
}
function collapse(){
  for(let c=0;c<COLS;c++){
    let write=ROWS-1;
    for(let r=ROWS-1;r>=0;r--){
      if(grid[r][c]!==null){
        if(write!==r){ grid[write][c]=grid[r][c]; grid[r][c]=null; }
        write--;
      }
    }
  }
}
function refill(){
  for(let c=0;c<COLS;c++){
    for(let r=0;r<ROWS;r++){
      if(grid[r][c]===null){ grid[r][c]=randColor(); }
    }
  }
}

/* =======================
   UI更新（ENバー・時間バー・READY）
======================= */
function updateBars(){
  const needR=getRequiredEN("RED",ctx), needB=getRequiredEN("BLUE",ctx), needY=getRequiredEN("YELLOW",ctx);
  const pct=(cur,need)=> (cur/need*100).toFixed(0)+'%';

  document.getElementById('bar-red').style.width   = pct(en.RED, needR);
  document.getElementById('bar-blue').style.width  = pct(en.BLUE, needB);
  document.getElementById('bar-yellow').style.width= pct(en.YELLOW, needY);

  document.getElementById('cap-red').textContent    = `目標: ${needR}`;
  document.getElementById('cap-blue').textContent   = `目標: ${needB}`;
  document.getElementById('cap-yellow').textContent = `目標: ${needY}`;

  toggleReady('red',   en.RED   >= needR);
  toggleReady('blue',  en.BLUE  >= needB);
  toggleReady('yellow',en.YELLOW>= needY);
}
function toggleReady(colorKey, on){
  const badge = document.getElementById(`badge-${colorKey}`);
  const wrap  = document.getElementById(`barwrap-${colorKey}`);
  badge.style.display = on ? 'inline-block' : 'none';
  wrap.classList.toggle('filled', on);
}

function updateTimeBars(){
  const pct=(cur)=> (cur/TIME_LIMIT_SECONDS*100).toFixed(0)+'%';
  document.getElementById('time-red').style.width    = pct(timeLeft.RED);
  document.getElementById('time-blue').style.width   = pct(timeLeft.BLUE);
  document.getElementById('time-yellow').style.width = pct(timeLeft.YELLOW);
}
// 任意で呼べる：その色のタイマーを満タンに戻す
function resetTimer(colorName){ timeLeft[colorName] = TIME_LIMIT_SECONDS; updateTimeBars(); }

/* =======================
   スキル「発動」ボタン（前段階仕様：ENリセット）
======================= */
document.getElementById('btn-red').addEventListener('click', ()=>{
  en.RED = 0; updateBars();
});
document.getElementById('btn-blue').addEventListener('click', ()=>{
  en.BLUE = 0; updateBars();
});
document.getElementById('btn-yellow').addEventListener('click', ()=>{
  en.YELLOW = 0; updateBars();
});

/* =======================
   小物
======================= */
function sleep(ms){ return new Promise(res=>setTimeout(res,ms)); }
</script>
</body>
</html>
