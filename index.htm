<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Buzzy Academy – データ駆動版（敵/プレイヤー切替・モバイル最適化）</title>
<style>
  :root{
    --cell:48px; --gap:6px;
    --barW: clamp(150px, 42vw, 250px); /* 少し短め固定：3行とも同一 */
    --bg:#0f172a; --panel:#111827; --muted:#9ca3af;
    --red:#ef4444; --blue:#3b82f6; --yellow:#f59e0b; --gray:#6b7280;
    --bar-bg:#1f2937; --btn:#374151; --btn-txt:#e5e7eb; --good:#10b981;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:#e5e7eb;font-family:system-ui,-apple-system,"Segoe UI",Roboto}
  #wrap{max-width:560px;margin:10px auto;padding:10px}
  h1{font-size:17px;margin:0 0 8px; display:flex; justify-content:space-between; align-items:center;}
  .debug-btn{padding:6px 10px;border-radius:8px;border:1px solid #4b5563;background:#0ea5e9;color:#083344;cursor:pointer}

  /* 折りたたみ設定（敵/プレイヤー選択） */
  details.cfgbox{background:#0b1222;border:1px solid #334155;border-radius:10px}
  details.cfgbox>summary{
    list-style:none; cursor:pointer; user-select:none; padding:8px 10px;
    color:#e5e7eb; font-size:14px; display:flex; align-items:center; justify-content:space-between;
  }
  details.cfgbox[open]>summary{border-bottom:1px solid #334155}
  .cfg{padding:8px; display:grid; grid-template-columns:1fr 1fr auto; gap:8px; align-items:center}
  .sel{background:#0b1222;color:#e5e7eb;border:1px solid #334155;border-radius:8px;padding:6px 8px}
  .cfg-hint{font-size:11px;color:var(--muted); padding:6px 10px 8px}

  /* 時間バー */
  .legend{display:flex;align-items:center;gap:8px;color:var(--muted);font-size:12px;margin-top:6px}
  .bar{height:10px;background:var(--bar-bg);border-radius:8px;overflow:hidden;position:relative}
  .fill{height:100%;width:0%;transition:width .25s}
  .cap{position:absolute;right:6px;top:-18px;font-size:11px;color:var(--muted)}

  /* 敵情報 */
  .enemy-top{display:grid;grid-template-columns:1fr 1fr 1fr;align-items:center;gap:6px;margin-top:8px}
  .e-col{display:flex;align-items:center;gap:8px;justify-content:flex-start}
  .e-mid{justify-content:center;font-weight:700;font-size:14px; line-height:1.2; text-align:center}
  .e-right{justify-content:flex-end}
  .attr-dot{width:12px;height:12px;border-radius:3px;display:inline-block}

  /* VS 2行表示（敵名 VS / 改行 / プレイヤー名） */
  .vs-wrap{display:flex; flex-direction:column; align-items:center; justify-content:center}
  .vs-top{white-space:nowrap}
  .vs-bot{white-space:nowrap; opacity:.9; font-weight:600}

  .enemy-img-wrap{display:flex;justify-content:center;align-items:center;margin-top:6px}
  .enemy-img{
    width:100%; max-width:440px; height:auto; max-height:100px;
    object-fit:contain; border-radius:12px;
    background:#ffffff; border:1px solid #e5e7eb;
    display:block; padding:6px;
  }
  .hpbar{height:10px;background:#334155;border-radius:8px;overflow:hidden;position:relative;margin-top:6px}
  .hpfill{height:100%;width:100%;background:var(--good);transition:width .25s}
  .hptext{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:11px;color:#e5e7eb;text-shadow:0 1px 0 #000}

  /* EN行（1行固定） */
  .row{display:grid;grid-template-columns:auto var(--barW) auto;gap:8px;align-items:center;margin-top:8px;min-height:32px}
  .skillinfo{font-size:13px;color:#e5e7eb;display:flex;align-items:center;gap:8px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:40vw}
  .dot{width:12px;height:12px;border-radius:3px;display:inline-block;flex:0 0 auto}
  .ready{font-size:11px;color:#fff;background:#16a34a;padding:2px 6px;border-radius:999px;margin-left:6px;display:none}
  .bar.en{width:var(--barW);height:10px}
  .filled{outline:2px solid #fff; outline-offset:-2px; box-shadow:0 0 10px 2px rgba(255,255,255,.5)}
  .btn{padding:7px 10px;border-radius:8px;border:1px solid #4b5563;background:var(--btn);color:var(--btn-txt);cursor:pointer;min-width:64px;transition:box-shadow .2s,transform .1s,background .2s}
  .btn:disabled{opacity:.6;cursor:not-allowed;background:#30353c;color:#b7bec7;border-color:#454b55}
  .btn.pulse{box-shadow:0 0 0 0 rgba(255,255,255,.8),0 0 10px 2px currentColor;animation:pulseGlow 1.2s ease-in-out infinite;background:linear-gradient(180deg,#55607a,#2d3441);border-color:#9aa2ad}
  @keyframes pulseGlow{0%{box-shadow:0 0 0 0 rgba(255,255,255,.8),0 0 10px 2px rgba(255,255,255,.6)}
  50%{box-shadow:0 0 20px 6px rgba(255,255,255,.35),0 0 16px 4px rgba(255,255,255,.55)}
  100%{box-shadow:0 0 0 0 rgba(255,255,255,0),0 0 10px 2px rgba(255,255,255,.35)}}

  .hint{font-size:11px;color:var(--muted);margin-top:6px}

  /* 盤面（中央寄せ） */
  #board{margin:10px auto 0;width:calc(6*var(--cell) + 5*var(--gap));display:grid;grid-template-columns:repeat(6,var(--cell));gap:var(--gap);background:var(--panel);padding:var(--gap);border-radius:12px;position:relative}
  .overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);border-radius:12px;font-size:24px;font-weight:800;z-index:9999}
  .cell{width:var(--cell);height:var(--cell);border-radius:50%;box-shadow:inset 0 -6px 0 rgba(0,0,0,.18);cursor:pointer;position:relative;transition:transform .08s,box-shadow .12s}
  .cell.red{background:var(--red)} .cell.blue{background:var(--blue)} .cell.yellow{background:var(--yellow)} .cell.gray{background:var(--gray)}
  .cell.selected{outline:3px solid #fff;outline-offset:-3px;box-shadow:0 0 10px 2px rgba(255,255,255,.6),inset 0 -6px 0 rgba(0,0,0,.18);transform:scale(1.06)}
  .shake{animation:shake .18s linear 1}
  @keyframes shake{0%{transform:translateX(0)}25%{transform:translateX(-3px)}50%{transform:translateX(3px)}75%{transform:translateX(-2px)}100%{transform:translateX(0)}}

  /* 狭幅でさらに圧縮：設定閉/画像＆盤面縮小、VS字さらに小さく */
  @media (max-width: 420px){
    :root{ --cell:42px; --barW: clamp(140px, 48vw, 220px); }
    #wrap{padding:8px}
    .enemy-img{max-height:90px}
    .e-mid{font-size:13px}
  }
  @media (max-width: 360px){
    :root{ --cell:38px; --barW: clamp(130px, 50vw, 200px); }
    .btn{padding:6px 8px; min-width:56px}
    .enemy-img{max-height:80px}
    .e-mid{font-size:12px}
  }
</style>
</head>
<body>
  <div id="wrap">
    <h1>
      <span>Buzzy Academy – データ駆動版</span>
      <button id="btn-reset" class="debug-btn" title="臨時デバッグ用：ゲームを即リセット">リセット</button>
    </h1>

    <!-- 折りたたみ設定：スマホは既定で閉じる -->
    <details class="cfgbox" id="cfgBox">
      <summary>設定（敵/プレイヤー切替）<span style="font-size:11px;color:#9ca3af;">タップで開閉</span></summary>
      <div class="cfg">
        <select id="enemy-select" class="sel" title="敵キャラクターを選択"></select>
        <select id="player-select" class="sel" title="プレイヤーを選択"></select>
        <button id="apply-btn" class="debug-btn" title="選択を反映しリセット">反映</button>
      </div>
      <div class="cfg-hint">※ スマホではプレイ中は閉じておくと画面内に収まりやすいです。</div>
    </details>

    <!-- 時間バー -->
    <div class="legend"><span id="time-legend">ステージ時間：</span></div>
    <div class="bar" id="time-wrap">
      <div id="time-fill" class="fill" style="background:#10b981;width:100%"></div>
      <span id="time-cap" class="cap"></span>
    </div>

    <!-- 敵情報 -->
    <div class="enemy-top">
      <div class="e-col">
        <span class="attr-dot" id="enemy-attr-dot"></span>
        <span id="enemy-attr-label" class="small"></span>
      </div>
      <div class="e-col e-mid">
        <div class="vs-wrap">
          <div class="vs-top" id="vs-top">あべこべ VS</div>
          <div class="vs-bot" id="vs-bot">めぐ</div>
        </div>
      </div>
      <div class="e-col e-right">HP: <span id="enemy-hpnum">1000</span></div>
    </div>

    <!-- 敵画像（白背景フレーム） -->
    <div class="enemy-img-wrap">
      <img id="enemy-img" class="enemy-img" src="images/char1.png" alt="enemy">
    </div>

    <!-- 敵HPバー -->
    <div class="hpbar"><div id="ehp" class="hpfill"></div><div id="ehptext" class="hptext"></div></div>

    <!-- EN：3行（各色1行固定） -->
    <div class="row">
      <div class="skillinfo">
        <span class="dot" style="background:var(--red)"></span>
        <span id="label-red"><b>パンチ</b>（<span id="rowpow-red"></span>）</span>
        <span id="badge-red" class="ready">READY</span>
      </div>
      <div class="bar en" id="barwrap-red"><div id="bar-red" class="fill" style="background:var(--red)"></div></div>
      <button id="btn-red" class="btn" disabled>発動</button>
    </div>

    <div class="row">
      <div class="skillinfo">
        <span class="dot" style="background:var(--blue)"></span>
        <span id="label-blue"><b>キック</b>（<span id="rowpow-blue"></span>）</span>
        <span id="badge-blue" class="ready">READY</span>
      </div>
      <div class="bar en" id="barwrap-blue"><div id="bar-blue" class="fill" style="background:var(--blue)"></div></div>
      <button id="btn-blue" class="btn" disabled>発動</button>
    </div>

    <div class="row">
      <div class="skillinfo">
        <span class="dot" style="background:var(--yellow)"></span>
        <span id="label-yellow"><b>つんつん</b>（<span id="rowpow-yellow"></span>）</span>
        <span id="badge-yellow" class="ready">READY</span>
      </div>
      <div class="bar en" id="barwrap-yellow"><div id="bar-yellow" class="fill" style="background:var(--yellow)"></div></div>
      <button id="btn-yellow" class="btn" disabled>発動</button>
    </div>

    <div class="hint">・プレイ中は上の「設定」を閉じるとスクロール不要で遊びやすくなります。</div>

    <!-- 盤面 -->
    <div id="board"><div id="overlay" class="overlay">TIME UP!</div></div>
  </div>

<script>
/* ====== 定数・ユーティリティ ====== */
const ROWS=6, COLS=6;
const ID = { RED:0, BLUE:1, YELLOW:2, GRAY:3 };
const NAME_BY_ID = { 0:"RED", 1:"BLUE", 2:"YELLOW", 3:"GRAY" };
const CLASS_BY_ID = { 0:"red", 1:"blue", 2:"yellow", 3:"gray" };

// ★ ステージ時間（秒）— ここを変えるだけでOK
const TIME_LIMIT_SECONDS = 90;

const RPS_RATE = { win:1.2, draw:1.0, lose:0.7 }; // じゃんけん倍率
const ATTR_LABEL = { RED:"赤 (グー)", BLUE:"青 (チョキ)", YELLOW:"黄 (パー)" };
const beats=(a,b)=> (a==="RED"&&b==="BLUE")||(a==="BLUE"&&b==="YELLOW")||(a==="YELLOW"&&b==="RED");
const rpsMul=(enemyAttr, skillColor)=> enemyAttr===skillColor? RPS_RATE.draw : (beats(skillColor, enemyAttr)? RPS_RATE.win : RPS_RATE.lose);

/* ====== データ（ここを編集すれば増減可能） ====== */
const ENEMIES = [
  { id:"goo-boss", name:"あべこべ",     attr:"RED",    maxHP:500,  imgSrc:"images/char1.png" },
  { id:"scis",     name:"仮面松にぃ",   attr:"BLUE",   maxHP:1000, imgSrc:"images/char2.png" },
  { id:"hand",     name:"スーツ松兄",   attr:"YELLOW", maxHP:1200, imgSrc:"images/char3.png" }
];

const PLAYERS = [
  { id:"meg",   name:"めぐ",   skills:{
      RED:{name:"パンチ",  power:50},
      BLUE:{name:"キック", power:100},
      YELLOW:{name:"つんつん", power:150}
  }},
  { id:"rio",   name:"Gジェネ好きめぐみん", skills:{
      RED:{name:"火炎拳",  power:80},
      BLUE:{name:"旋風脚", power:90},
      YELLOW:{name:"光突き",power:120}
  }},
  { id:"buzzy", name:"仮面ライダー愛", skills:{
      RED:{name:"ハチパンチ", power:60},
      BLUE:{name:"スラッシュ", power:110},
      YELLOW:{name:"ニードル",  power:130}
  }}
];

/* ====== 可変状態 ====== */
let enemy = structuredClone(ENEMIES[0]);
let player = structuredClone(PLAYERS[0]);
const baseEnTarget = { RED:30, BLUE:30, YELLOW:30 }; // EN目標（色ごと）
let timeLeft = TIME_LIMIT_SECONDS, timer=null, gameOver=false;
let grid=[], firstPick=null, en={RED:0,BLUE:0,YELLOW:0}, busy=false;

/* ====== セレクタ ====== */
const enemySel  = document.getElementById('enemy-select');
const playerSel = document.getElementById('player-select');
const applyBtn  = document.getElementById('apply-btn');
function populateSelectors(){
  // 敵：名前のみ表示（属性・HPは非表示）
  enemySel.innerHTML  = ENEMIES.map((e,i)=>`<option value="${i}">${e.name}</option>`).join('');
  playerSel.innerHTML = PLAYERS.map((p,i)=>`<option value="${i}">${p.name}</option>`).join('');
  enemySel.value = ENEMIES.findIndex(e=>e.id===enemy.id);
  playerSel.value = PLAYERS.findIndex(p=>p.id===player.id);
}
applyBtn.addEventListener('click', ()=>{
  const ei = +enemySel.value, pi = +playerSel.value;
  enemy  = structuredClone(ENEMIES[ei]);
  player = structuredClone(PLAYERS[pi]);
  resetGame();
  // スマホでは反映後に自動で設定を閉じ、画面内に収める
  const cfg = document.getElementById('cfgBox');
  if(window.matchMedia('(max-width: 420px)').matches) cfg.open = false;
});

/* ====== 時間周り ====== */
function renderTimeLegend(){
  document.getElementById('time-legend').textContent = `ステージ時間：${TIME_LIMIT_SECONDS}秒`;
}
function startTimer(){
  stopTimer();
  timer=setInterval(()=>{
    if(gameOver) return;
    if(timeLeft>0){
      timeLeft--;
      updateTimeBar();
      if(timeLeft===0) onGameOver();
    }
  },1000);
}
function stopTimer(){ if(timer){ clearInterval(timer); timer=null; } }
function updateTimeBar(){
  const pct=(timeLeft/TIME_LIMIT_SECONDS*100).toFixed(0)+'%';
  document.getElementById('time-fill').style.width=pct;
  document.getElementById('time-cap').textContent=`残り: ${timeLeft}s / ${TIME_LIMIT_SECONDS}s`;
}

/* ====== 表示更新 ====== */
function renderEnemyHeader(){
  // VS 2行表示
  document.getElementById('vs-top').textContent = `${enemy.name} VS`;
  document.getElementById('vs-bot').textContent = `${player.name}`;
  document.getElementById('enemy-hpnum').textContent=enemy.hp;
  document.getElementById('enemy-attr-dot').style.background=(enemy.attr==="RED"?"var(--red)":enemy.attr==="BLUE"?"var(--blue)":"var(--yellow)");
  document.getElementById('enemy-attr-label').textContent=ATTR_LABEL[enemy.attr];
  document.getElementById('enemy-img').src = enemy.imgSrc;
}
function updateEnemyHPBar(){
  const pct=(enemy.hp/enemy.maxHP*100).toFixed(0)+'%';
  document.getElementById('ehp').style.width=pct;
  document.getElementById('ehptext').textContent=`${enemy.hp}/${enemy.maxHP}`;
  document.getElementById('enemy-hpnum').textContent=enemy.hp;
}
function renderPlayerLabels(){
  document.getElementById('label-red').innerHTML    = `<b>${player.skills.RED.name}</b>（<span id="rowpow-red">${player.skills.RED.power}</span>）`;
  document.getElementById('label-blue').innerHTML   = `<b>${player.skills.BLUE.name}</b>（<span id="rowpow-blue">${player.skills.BLUE.power}</span>）`;
  document.getElementById('label-yellow').innerHTML = `<b>${player.skills.YELLOW.name}</b>（<span id="rowpow-yellow">${player.skills.YELLOW.power}</span>）`;
}

/* ====== EN関連 ====== */
function getRequiredEN(colorName){ return baseEnTarget[colorName]; }
const baseGainMult={3:1.0,4:1.5,5:2.0};
const gainChain=(chain)=>1+Math.min(chain-1,4)*0.05;
function getGainAmount(colorName, matchedCount, chain=1){
  if(colorName==="GRAY")return 0;
  const base=matchedCount*(matchedCount>=5?baseGainMult[5]:(baseGainMult[matchedCount]||1.0));
  return Math.max(0, Math.round(base*gainChain(chain)));
}
function updateBars(){
  const needR=getRequiredEN("RED"), needB=getRequiredEN("BLUE"), needY=getRequiredEN("YELLOW");
  const pct=(cur,need)=> Math.max(0,Math.min(100,(cur/need*100))).toFixed(0)+'%';
  document.getElementById('bar-red').style.width=pct(en.RED,needR);
  document.getElementById('bar-blue').style.width=pct(en.BLUE,needB);
  document.getElementById('bar-yellow').style.width=pct(en.YELLOW,needY);

  const rReady=en.RED>=needR, bReady=en.BLUE>=needB, yReady=en.YELLOW>=needY;
  toggleReady('red', rReady); toggleReady('blue', bReady); toggleReady('yellow', yReady);
  setButtonEnabled('red', rReady && !gameOver);
  setButtonEnabled('blue', bReady && !gameOver);
  setButtonEnabled('yellow', yReady && !gameOver);
}
function toggleReady(colorKey,on){
  const badge=document.getElementById(`badge-${colorKey}`);
  const wrap=document.getElementById(`barwrap-${colorKey}`);
  badge.style.display=on?'inline-block':'none';
  wrap.classList.toggle('filled',on);
}
function setButtonEnabled(colorKey,on){
  const btn=document.getElementById(`btn-${colorKey}`);
  btn.disabled=!on;
  btn.classList.toggle('pulse', on); // READY時に光る
}

/* ====== 盤面ロジック ====== */
const board=document.getElementById('board');
function initBoard(){
  grid=Array.from({length:ROWS},()=>Array(COLS).fill(0));
  for(let r=0;r<ROWS;r++){ for(let c=0;c<COLS;c++){
    let color; do{ color=randColor(); }while(causesImmediateMatch(r,c,color)); grid[r][c]=color;
  } }
}
function renderAll(){
  board.innerHTML='';
  const ov=document.createElement('div'); ov.id='overlay'; ov.className='overlay'; ov.textContent='TIME UP!'; board.appendChild(ov);
  for(let r=0;r<ROWS;r++){ for(let c=0;c<COLS;c++){
    const div=document.createElement('div');
    div.className='cell '+CLASS_BY_ID[grid[r][c]];
    div.dataset.r=r; div.dataset.c=c;
    div.addEventListener('click', onCellClick, {passive:true});
    board.appendChild(div);
  } }
}
function onCellClick(e){
  if(busy||gameOver)return;
  const r=+e.currentTarget.dataset.r, c=+e.currentTarget.dataset.c;
  if(!firstPick){ firstPick={r,c}; highlight(r,c,true); return; }
  if(firstPick.r===r && firstPick.c===c){ highlight(r,c,false); firstPick=null; return; }
  const dr=Math.abs(firstPick.r-r), dc=Math.abs(firstPick.c-c);
  if(dr+dc!==1){ e.currentTarget.classList.add('shake'); setTimeout(()=>e.currentTarget.classList.remove('shake'),220); return; }
  const r1=firstPick.r,c1=firstPick.c,r2=r,c2=c; highlight(r1,c1,false); firstPick=null; trySwap(r1,c1,r2,c2);
}
function highlight(r,c,on){ const idx=r*COLS+c, el=board.children[idx+1]; if(!el)return; if(on)el.classList.add('selected'); else el.classList.remove('selected'); }
async function trySwap(r1,c1,r2,c2){
  if (busy) return;
  busy = true;
  try{
    swapInData(r1,c1,r2,c2);
    renderAll();
    const matches = findMatches();
    if(matches.set.size===0){
      swapInData(r1,c1,r2,c2);
      renderAll();
    }else{
      await resolveBoard(matches, 1);
    }
  } finally {
    busy = false;
  }
}
function swapInData(r1,c1,r2,c2){ const t=grid[r1][c1]; grid[r1][c1]=grid[r2][c2]; grid[r2][c2]=t; }
function findMatches(){
  const toClear=new Set();
  for(let r=0;r<ROWS;r++){ let run=grid[r][0], s=0; for(let c=1;c<=COLS;c++){ const col=(c<COLS)?grid[r][c]:-1; if(col!==run){ const len=c-s; if(len>=3){ for(let k=s;k<c;k++) toClear.add(`${r},${k}`);} run=col; s=c; } } }
  for(let c=0;c<COLS;c++){ let run=grid[0][c], s=0; for(let r=1;r<=ROWS;r++){ const col=(r<ROWS)?grid[r][c]:-1; if(col!==run){ const len=r-s; if(len>=3){ for(let k=s;k<r;k++) toClear.add(`${k},${c}`);} run=col; s=r; } } }
  const groups={}; for(const key of toClear){ const [r,c]=key.split(',').map(Number); const colId=grid[r][c]; const name=NAME_BY_ID[colId]; groups[name]=(groups[name]||0)+1; }
  return { set:toClear, groups };
}
async function resolveBoard(matches,chain){
  applyEN(matches.groups,chain);
  for(const key of matches.set){ const [r,c]=key.split(',').map(Number); grid[r][c]=null; }
  renderAll(); collapse(); refill(); renderAll();
  const next=findMatches(); if(next.set.size>0){ await sleep(120); return resolveBoard(next,chain+1); }
}
function applyEN(groups,chain){
  for(const colorName in groups){
    const count=groups[colorName];
    const add=getGainAmount(colorName,count,chain);
    if(colorName in en){ const need=getRequiredEN(colorName); en[colorName]=Math.min(need,en[colorName]+add); }
  }
  updateBars();
}
function collapse(){ for(let c=0;c<COLS;c++){ let w=ROWS-1; for(let r=ROWS-1;r>=0;r--){ if(grid[r][c]!==null){ if(w!==r){ grid[w][c]=grid[r][c]; grid[r][c]=null; } w--; } } } }
function refill(){ for(let c=0;c<COLS;c++){ for(let r=0;r<ROWS;r++){ if(grid[r][c]===null){ grid[r][c]=randColor(); } } } }
function randColor(){ return Math.floor(Math.random()*4); }
function causesImmediateMatch(r,c,color){ if(c>=2&&grid[r][c-1]===color&&grid[r][c-2]===color)return true; if(r>=2&&grid[r-1][c]===color&&grid[r-2][c]===color)return true; return false; }

/* ====== スキル発動 ====== */
document.getElementById('btn-red').addEventListener('click', ()=> useSkill("RED"));
document.getElementById('btn-blue').addEventListener('click', ()=> useSkill("BLUE"));
document.getElementById('btn-yellow').addEventListener('click', ()=> useSkill("YELLOW"));
function useSkill(color){
  if(gameOver) return;
  const need=getRequiredEN(color); if(en[color]<need) return;
  const power=player.skills[color].power;
  const mult=rpsMul(enemy.attr,color);
  const dmg=Math.max(1,Math.round(power*mult));
  enemy.hp=Math.max(0,enemy.hp-dmg); updateEnemyHPBar();
  en[color]=0; updateBars();
  if(enemy.hp===0){ stopTimer(); showOverlay("VICTORY!"); gameOver=true; }
}

/* ====== ゲームオーバー＆リセット ====== */
function onGameOver(){ gameOver=true; showOverlay("TIME UP!"); setButtonEnabled('red',false); setButtonEnabled('blue',false); setButtonEnabled('yellow',false); }
function showOverlay(text){ const o=document.getElementById('overlay'); o.textContent=text; o.style.display='flex'; }
function hideOverlay(){ document.getElementById('overlay').style.display='none'; }
document.getElementById('btn-reset').addEventListener('click', resetGame);

/* ====== 雑多 ====== */
function sleep(ms){ return new Promise(resolve => setTimeout(resolve, ms)); }
function resetGame(){
  enemy.hp = enemy.maxHP;
  gameOver=false; busy=false; firstPick=null; en={RED:0,BLUE:0,YELLOW:0};
  timeLeft=TIME_LIMIT_SECONDS;
  renderTimeLegend();                 // ★ ここで時間ラベルも更新
  updateTimeBar();
  renderEnemyHeader(); updateEnemyHPBar(); renderPlayerLabels();
  initBoard(); renderAll(); updateBars();
  hideOverlay(); startTimer();
}

/* ====== 起動 ====== */
(function boot(){
  populateSelectors();
  // スマホは初期状態で設定を閉じておく
  const cfg = document.getElementById('cfgBox');
  if(window.matchMedia('(max-width: 420px)').matches) cfg.open = false;
  resetGame();
})();
</script>
</body>
</html>

