<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Buzzy Academy – データ駆動版（敵/プレイヤー切替・モバイル最適化）</title>
<style>
  :root{
    --cell:48px; --gap:6px;
    --barW: clamp(150px, 42vw, 250px);
    --bg:#0f172a; --panel:#111827; --muted:#9ca3af;
    --red:#ef4444; --blue:#3b82f6; --yellow:#f59e0b; --gray:#6b7280;
    --bar-bg:#1f2937; --btn:#374151; --btn-txt:#e5e7eb; --good:#10b981;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:#e5e7eb;font-family:system-ui,-apple-system,"Segoe UI",Roboto}
  #wrap{max-width:560px;margin:10px auto;padding:10px}
  h1{font-size:17px;margin:0 0 8px; display:flex; justify-content:space-between; align-items:center;}
  .debug-btn{padding:6px 10px;border-radius:8px;border:1px solid #4b5563;background:#0ea5e9;color:#083344;cursor:pointer}

  /* 設定（折りたたみ） */
  details.cfgbox{background:#0b1222;border:1px solid #334155;border-radius:10px}
  details.cfgbox>summary{
    list-style:none; cursor:pointer; user-select:none; padding:8px 10px;
    color:#e5e7eb; font-size:14px; display:flex; align-items:center; justify-content:space-between;
  }
  details.cfgbox[open]>summary{border-bottom:1px solid #334155}
  .cfg{padding:8px; display:grid; grid-template-columns:1fr 1fr auto; gap:8px; align-items:center}
  .sel{background:#0b1222;color:#e5e7eb;border:1px solid #334155;border-radius:8px;padding:6px 8px}
  .cfg-hint{font-size:11px;color:var(--muted); padding:6px 10px 8px}

  /* バー共通 */
  .bar{height:10px;background:var(--bar-bg);border-radius:8px;overflow:hidden;position:relative}
  .fill{height:100%;width:0%;transition:width .25s}
  /* ★TIME専用：右端固定で縮む＝左→右に減る見え方 */
  .fill.right{position:absolute; right:0; top:0; bottom:0;}
  .cap-inline{font-size:11px;color:var(--muted);margin-left:6px}

  /* ← 新規：TIME/HP を1行2分割で配置 */
  .dual-bars{
    display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:6px;
  }
  .barbox{display:flex; flex-direction:column; gap:4px}
  .barlabel{font-size:12px; color:var(--muted); display:flex; align-items:center; justify-content:space-between}

  /* 敵情報（HPはここに出さない） */
  .enemy-top{
    display:grid;
    grid-template-columns:auto 1fr;
    align-items:center; gap:8px; margin-top:8px
  }
  .e-col{display:flex;align-items:center;gap:8px}
  .attr-dot{width:12px;height:12px;border-radius:3px;display:inline-block}
  .attr-label{font-size:13px;color:var(--muted)}
  .vs-line{font-weight:700;font-size:14px; line-height:1.2; text-align:center; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
  .vs-line{ word-spacing: 0.8em; } /* VS左右の間隔 */

  /* 画像枠：左=敵 / 中央=VS / 右=プレイヤー */
  .battle-visual{
    display:grid; grid-template-columns:1fr auto 1fr; align-items:center;
    gap:8px; margin-top:8px;
    background:#ffffff; border:1px solid #e5e7eb; border-radius:12px; padding:6px;
  }
  .battle-img{
    width:100%; max-width:210px; height:auto; max-height:100px; object-fit:contain; display:block;
    background:#fff; border-radius:8px;
  }
  .battle-center{ display:flex; align-items:center; justify-content:center; min-width:40px; padding:0 6px; }
  .vs-text{color:#111827; font-weight:800; font-size:20px; letter-spacing:1px}

  /* EN行（攻撃行） */
  .row{
    display:grid;
    grid-template-columns: minmax(0,1fr) var(--barW) auto; /* 左:縮む / 中:固定幅 / 右:ボタン */
    gap:8px; align-items:center; margin-top:8px; min-height:32px;
  }
  .skillinfo{
    font-size:13px; color:#e5e7eb; display:flex; align-items:center; gap:8px;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis; min-width:0;
  }
  .dot{width:12px;height:12px;border-radius:3px;display:inline-block;flex:0 0 auto}
  .ready{
    font-size:11px;color:#fff;background:#16a34a;padding:2px 6px;border-radius:999px;margin-left:6px;
    display:inline-block; visibility:hidden; min-width:54px; text-align:center;
  }
  .bar.en{width:var(--barW);height:10px}
  .filled{outline:2px solid #fff; outline-offset:-2px; box-shadow:0 0 10px 2px rgba(255,255,255,.5)}
  .btn{padding:7px 10px;border-radius:8px;border:1px solid #4b5563;background:var(--btn);color:#e5e7eb;cursor:pointer;min-width:64px;transition:box-shadow .2s,transform .1s,background .2s}
  .btn:disabled{opacity:.6;cursor:not-allowed;background:#30353c;color:#b7bec7;border-color:#454b55}
  .btn.pulse{box-shadow:0 0 0 0 rgba(255,255,255,.8),0 0 10px 2px currentColor;animation:pulseGlow 1.2s ease-in-out infinite;background:linear-gradient(180deg,#55607a,#2d3441);border-color:#9aa2ad}
  @keyframes pulseGlow{0%{box-shadow:0 0 0 0 rgba(255,255,255,.8),0 0 10px 2px rgba(255,255,255,.6)}
  50%{box-shadow:0 0 20px 6px rgba(255,255,255,.35),0 0 16px 4px rgba(255,255,255,.55)}
  100%{box-shadow:0 0 0 0 rgba(255,255,255,0),0 0 10px 2px rgba(255,255,255,.35)}}

  .hint{font-size:11px;color:var(--muted);margin-top:6px}

  /* 盤面（中央寄せ） */
  #board{margin:10px auto 0;width:calc(6*var(--cell) + 5*var(--gap));display:grid;grid-template-columns:repeat(6,var(--cell));gap:var(--gap);background:var(--panel);padding:var(--gap);border-radius:12px;position:relative}
  .overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);border-radius:12px;font-size:24px;font-weight:800;z-index:9999}
  .cell{width:var(--cell);height:var(--cell);border-radius:50%;box-shadow:inset 0 -6px 0 rgba(0,0,0,.18);cursor:pointer;position:relative;transition:transform .08s,box-shadow .12s}
  .cell.red{background:var(--red)} .cell.blue{background:var(--blue)} .cell.yellow{background:var(--yellow)} .cell.gray{background:var(--gray)}
  .cell.selected{outline:3px solid #fff;outline-offset:-3px;box-shadow:0 0 10px 2px rgba(255,255,255,.6),inset 0 -6px 0 rgba(0,0,0,.18);transform:scale(1.06)}
  .shake{animation:shake .18s linear 1}
  @keyframes shake{0%{transform:translateX(0)}25%{transform:translateX(-3px)}50%{transform:translateX(3px)}75%{transform:translateX(-2px)}100%{transform:translateX(0)}}

  /* 狭幅向け微調整 */
  @media (max-width: 420px){
    :root{ --cell:42px; --barW: clamp(140px, 48vw, 220px); }
    #wrap{padding:8px}
    .battle-img{max-height:90px}
    .vs-text{font-size:18px}
    .vs-line{font-size:13px}
  }
  @media (max-width: 360px){
    :root{ --cell:38px; --barW: clamp(130px, 50vw, 200px); }
    .btn{padding:6px 8px; min-width:56px}
    .battle-img{max-height:80px}
    .vs-text{font-size:16px}
    .vs-line{font-size:12px}
  }
</style>
</head>
<body>
  <div id="wrap">
    <h1>
      <span>Buzzy Academy – データ駆動版</span>
      <button id="btn-reset" class="debug-btn" title="臨時デバッグ用：ゲームを即リセット">リセット</button>
    </h1>

    <!-- 設定（スマホは既定で閉） -->
    <details class="cfgbox" id="cfgBox">
      <summary>設定（敵/プレイヤー切替）<span style="font-size:11px;color:#9ca3af;">タップで開閉</span></summary>
      <div class="cfg">
        <select id="enemy-select" class="sel" title="敵キャラクターを選択"></select>
        <select id="player-select" class="sel" title="プレイヤーを選択"></select>
        <button id="apply-btn" class="debug-btn" title="選択を反映しリセット">反映</button>
      </div>
      <div class="cfg-hint">※ プレイ中は閉じると収まりが良くなります。</div>
    </details>

    <!-- ▼▼ 新：TIME/HP の2分割行（4行目相当） ▼▼ -->
    <div class="dual-bars">
      <!-- TIME（左） -->
      <div class="barbox">
        <div class="barlabel">
          <span>TIME</span>
          <span id="time-cap" class="cap-inline"></span>
        </div>
        <div class="bar" id="time-wrap">
          <!-- ★ここ：rightクラスを追加して右端固定で縮む -->
          <div id="time-fill" class="fill right" style="background:#10b981;width:100%"></div>
        </div>
      </div>
      <!-- HP（右） -->
      <div class="barbox">
        <div class="barlabel">
          <span>HP</span>
          <span id="hp-cap" class="cap-inline"></span>
        </div>
        <div class="bar" id="hp-wrap">
          <div id="hp-fill" class="fill" style="background:var(--good);width:100%"></div>
        </div>
      </div>
    </div>
    <!-- ▲▲ 既存の「ステージ時間：…」凡例は非表示/削除 ▲▲ -->

    <!-- 属性 / VS（1行・HPなし） -->
    <div class="enemy-top">
      <div class="e-col">
        <span class="attr-dot" id="enemy-attr-dot"></span>
        <span id="enemy-attr-label" class="attr-label"></span>
      </div>
      <div class="vs-line" id="vs-line">あべこべ VS めぐ</div>
    </div>

    <!-- 画像枠：左=敵 / 中央=VS / 右=プレイヤー -->
    <div class="battle-visual">
      <img id="enemy-img" class="battle-img" src="images/char1.png" alt="enemy">
      <div class="battle-center" id="fx-area"><span class="vs-text">VS</span></div>
      <img id="player-img" class="battle-img" src="images/play1.png" alt="player">
    </div>

    <!-- EN：3行 -->
    <div class="row">
      <div class="skillinfo">
        <span class="dot" style="background:var(--red)"></span>
        <span id="label-red"><b>パンチ</b>（<span id="rowpow-red"></span>）</span>
        <span id="badge-red" class="ready">READY</span>
      </div>
      <div class="bar en" id="barwrap-red"><div id="bar-red" class="fill" style="background:var(--red)"></div></div>
      <button id="btn-red" class="btn" disabled>発動</button>
    </div>

    <div class="row">
      <div class="skillinfo">
        <span class="dot" style="background:var(--blue)"></span>
        <span id="label-blue"><b>キック</b>（<span id="rowpow-blue"></span>）</span>
        <span id="badge-blue" class="ready">READY</span>
      </div>
      <div class="bar en" id="barwrap-blue"><div id="bar-blue" class="fill" style="background:var(--blue)"></div></div>
      <button id="btn-blue" class="btn" disabled>発動</button>
    </div>

    <div class="row">
      <div class="skillinfo">
        <span class="dot" style="background:var(--yellow)"></span>
        <span id="label-yellow"><b>つんつん</b>（<span id="rowpow-yellow"></span>）</span>
        <span id="badge-yellow" class="ready">READY</span>
      </div>
      <div class="bar en" id="barwrap-yellow"><div id="bar-yellow" class="fill" style="background:var(--yellow)"></div></div>
      <button id="btn-yellow" class="btn" disabled>発動</button>
    </div>

    <div class="hint">・プレイ中は上の「設定」を閉じるとスクロール不要で遊びやすくなります。</div>

    <!-- 盤面 -->
    <div id="board"><div id="overlay" class="overlay">TIME UP!</div></div>
  </div>

<script>
/* ====== 定数・ユーティリティ ====== */
const ROWS=6, COLS=6;
const ID = { RED:0, BLUE:1, YELLOW:2, GRAY:3 };
const NAME_BY_ID = { 0:"RED", 1:"BLUE", 2:"YELLOW", 3:"GRAY" };
const CLASS_BY_ID = { 0:"red", 1:"blue", 2:"yellow", 3:"gray" };

// ステージ時間（秒）
const TIME_LIMIT_SECONDS = 120;

const RPS_RATE = { win:1.2, draw:1.0, lose:0.7 };
const ATTR_LABEL = { RED:"赤 (グー)", BLUE:"青 (チョキ)", YELLOW:"黄 (パー)" };
const beats=(a,b)=> (a==="RED"&&b==="BLUE")||(a==="BLUE"&&b==="YELLOW")||(a==="YELLOW"&&b==="RED");
const rpsMul=(enemyAttr, skillColor)=> enemyAttr===skillColor? RPS_RATE.draw : (beats(skillColor, enemyAttr)? RPS_RATE.win : RPS_RATE.lose);

/* ====== データ ====== */
const ENEMIES = [
  { id:"goo-boss", name:"あべこべ",     attr:"RED",    maxHP:500,  imgSrc:"images/char1.png" },
  { id:"scis",     name:"仮面松にぃ",   attr:"BLUE",   maxHP:1000, imgSrc:"images/char2.png" },
  { id:"hand",     name:"スーツ松兄",   attr:"YELLOW", maxHP:1200, imgSrc:"images/char3.png" }
];

const PLAYERS = [
  { id:"meg",   name:"めぐ",   imgSrc:"images/play1.png", skills:{
      RED:{name:"パンチ",  power:50},
      BLUE:{name:"キック", power:100},
      YELLOW:{name:"つんつん", power:150}
  }},
  { id:"rio",   name:"Gジェネ好きめぐみん", imgSrc:"images/play2.png", skills:{
      RED:{name:"火炎拳",  power:80},
      BLUE:{name:"旋風脚", power:90},
      YELLOW:{name:"光突き",power:120}
  }},
  { id:"buzzy", name:"仮面ライダー愛", imgSrc:"images/play3.png", skills:{
      RED:{name:"ハチパンチ", power:60},
      BLUE:{name:"スラッシュ", power:110},
      YELLOW:{name:"ニードル",  power:130}
  }}
];

/* ====== 可変状態 ====== */
let enemy = structuredClone(ENEMIES[0]);
let player = structuredClone(PLAYERS[0]);
const baseEnTarget = { RED:30, BLUE:30, YELLOW:30 };
let timeLeft = TIME_LIMIT_SECONDS, timer=null, gameOver=false;
let grid=[], firstPick=null, en={RED:0,BLUE:0,YELLOW:0}, busy=false;

/* ====== セレクタ ====== */
const enemySel  = document.getElementById('enemy-select');
const playerSel = document.getElementById('player-select');
const applyBtn  = document.getElementById('apply-btn');
function populateSelectors(){
  enemySel.innerHTML  = ENEMIES.map((e,i)=>`<option value="${i}">${e.name}</option>`).join('');
  playerSel.innerHTML = PLAYERS.map((p,i)=>`<option value="${i}">${p.name}</option>`).join('');
  enemySel.value = ENEMIES.findIndex(e=>e.id===enemy.id);
  playerSel.value = PLAYERS.findIndex(p=>p.id===player.id);
}
applyBtn.addEventListener('click', ()=>{
  const ei = +enemySel.value, pi = +playerSel.value;
  enemy  = structuredClone(ENEMIES[ei]);
  player = structuredClone(PLAYERS[pi]);
  resetGame();
  const cfg = document.getElementById('cfgBox');
  if(window.matchMedia('(max-width: 420px)').matches) cfg.open = false;
});

/* ====== 時間・HPバー ====== */
function startTimer(){
  stopTimer();
  timer=setInterval(()=>{
    if(gameOver) return;
    if(timeLeft>0){
      timeLeft--;
      updateTimeBar();
      if(timeLeft===0) onGameOver();
    }
  },1000);
}
function stopTimer(){ if(timer){ clearInterval(timer); timer=null; } }
function updateTimeBar(){
  const pct = Math.max(0, Math.min(100, (timeLeft/TIME_LIMIT_SECONDS*100)));
  document.getElementById('time-fill').style.width = pct.toFixed(0) + '%';
  document.getElementById('time-cap').textContent  = `${timeLeft}s / ${TIME_LIMIT_SECONDS}s`;
}

/* ====== 画像フォールバック ====== */
function setImgWithFallback(imgEl, src){
  const placeholder = 'data:image/svg+xml;utf8,' +
    encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="240" height="120">
      <rect width="100%" height="100%" fill="#f3f4f6"/>
      <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="#9ca3af" font-family="Arial" font-size="16">NO IMAGE</text>
    </svg>`);
  imgEl.onerror = ()=>{ imgEl.onerror=null; imgEl.src = placeholder; };
  imgEl.src = src || placeholder;
}

/* ====== 表示更新 ====== */
function renderEnemyHeader(){
  document.getElementById('vs-line').textContent = `${enemy.name} VS ${player.name}`;
  document.getElementById('enemy-attr-dot').style.background =
    (enemy.attr==="RED"?"var(--red)":enemy.attr==="BLUE"?"var(--blue)":"var(--yellow)");
  document.getElementById('enemy-attr-label').textContent = ATTR_LABEL[enemy.attr];
  setImgWithFallback(document.getElementById('enemy-img'),  enemy.imgSrc);
  setImgWithFallback(document.getElementById('player-img'), player.imgSrc);
}
function updateHPBar(){
  const pct = Math.max(0, Math.min(100, (enemy.hp/enemy.maxHP*100)));
  document.getElementById('hp-fill').style.width = pct.toFixed(0) + '%';
  document.getElementById('hp-cap').textContent  = `${enemy.hp}/${enemy.maxHP}`;
}
function renderPlayerLabels(){
  document.getElementById('label-red').innerHTML    = `<b>${player.skills.RED.name}</b>（<span id="rowpow-red">${player.skills.RED.power}</span>）`;
  document.getElementById('label-blue').innerHTML   = `<b>${player.skills.BLUE.name}</b>（<span id="rowpow-blue">${player.skills.BLUE.power}</span>）`;
  document.getElementById('label-yellow').innerHTML = `<b>${player.skills.YELLOW.name}</b>（<span id="rowpow-yellow">${player.skills.YELLOW.power}</span>）`;
}

/* ====== EN関連 ====== */
function getRequiredEN(colorName){ return baseEnTarget[colorName]; }
const baseGainMult={3:1.0,4:1.5,5:2.0};
const gainChain=(chain)=>1+Math.min(chain-1,4)*0.05;
function getGainAmount(colorName, matchedCount, chain=1){
  if(colorName==="GRAY")return 0;
  const base=matchedCount*(matchedCount>=5?baseGainMult[5]:(baseGainMult[matchedCount]||1.0));
  return Math.max(0, Math.round(base*gainChain(chain)));
}
function updateBars(){
  const needR=getRequiredEN("RED"), needB=getRequiredEN("BLUE"), needY=getRequiredEN("YELLOW");
  const pct=(cur,need)=> Math.max(0,Math.min(100,(cur/need*100))).toFixed(0)+'%';
  document.getElementById('bar-red').style.width=pct(en.RED,needR);
  document.getElementById('bar-blue').style.width=pct(en.BLUE,needB);
  document.getElementById('bar-yellow').style.width=pct(en.YELLOW,needY);

  const rReady=en.RED>=needR, bReady=en.BLUE>=needB, yReady=en.YELLOW>=needY;
  toggleReady('red', rReady); toggleReady('blue', bReady); toggleReady('yellow', yReady);
  setButtonEnabled('red', rReady && !gameOver);
  setButtonEnabled('blue', bReady && !gameOver);
  setButtonEnabled('yellow', yReady && !gameOver);
}
function toggleReady(colorKey,on){
  const badge=document.getElementById(`badge-${colorKey}`);
  const wrap=document.getElementById(`barwrap-${colorKey}`);
  badge.style.visibility = on ? 'visible' : 'hidden';
  wrap.classList.toggle('filled',on);
}
function setButtonEnabled(colorKey,on){
  const btn=document.getElementById(`btn-${colorKey}`);
  btn.disabled=!on;
  btn.classList.toggle('pulse', on);
}

/* ====== 盤面ロジック ====== */
const board=document.getElementById('board');
function initBoard(){
  grid=Array.from({length:ROWS},()=>Array(COLS).fill(0));
  for(let r=0;r<ROWS;r++){ for(let c=0;c<COLS;c++){
    let color; do{ color=randColor(); }while(causesImmediateMatch(r,c,color)); grid[r][c]=color;
  } }
}
function renderAll(){
  board.innerHTML='';
  const ov=document.createElement('div'); ov.id='overlay'; ov.className='overlay'; ov.textContent='TIME UP!'; board.appendChild(ov);
  for(let r=0;r<ROWS;r++){ for(let c=0;c<COLS;c++){
    const div=document.createElement('div');
    div.className='cell '+CLASS_BY_ID[grid[r][c]];
    div.dataset.r=r; div.dataset.c=c;
    div.addEventListener('click', onCellClick, {passive:true});
    board.appendChild(div);
  } }
}
function onCellClick(e){
  if(busy||gameOver)return;
  const r=+e.currentTarget.dataset.r, c=+e.currentTarget.dataset.c;
  if(!firstPick){ firstPick={r,c}; highlight(r,c,true); return; }
  if(firstPick.r===r && firstPick.c===c){ highlight(r,c,false); firstPick=null; return; }
  const dr=Math.abs(firstPick.r-r), dc=Math.abs(firstPick.c-c);
  if(dr+dc!==1){ e.currentTarget.classList.add('shake'); setTimeout(()=>e.currentTarget.classList.remove('shake'),220); return; }
  const r1=firstPick.r,c1=firstPick.c,r2=r,c2=c; highlight(r1,c1,false); firstPick=null; trySwap(r1,c1,r2,c2);
}
function highlight(r,c,on){ const idx=r*COLS+c, el=board.children[idx+1]; if(!el)return; if(on)el.classList.add('selected'); else el.classList.remove('selected'); }
async function trySwap(r1,c1,r2,c2){
  if (busy) return;
  busy = true;
  try{
    swapInData(r1,c1,r2,c2);
    renderAll();
    const matches = findMatches();
    if(matches.set.size===0){
      swapInData(r1,c1,r2,c2);
      renderAll();
    }else{
      await resolveBoard(matches, 1);
    }
  } finally {
    busy = false;
  }
}
function swapInData(r1,c1,r2,c2){ const t=grid[r1][c1]; grid[r1][c1]=grid[r2][c2]; grid[r2][c2]=t; }
function findMatches(){
  const toClear=new Set();
  for(let r=0;r<ROWS;r++){
    let run=grid[r][0], s=0;
    for(let c=1;c<=COLS;c++){
      const col=(c<COLS)?grid[r][c]:-1;
      if(col!==run){
        const len=c-s; if(len>=3){ for(let k=s;k<c;k++) toClear.add(`${r},${k}`); }
        run=col; s=c;
      }
    }
  }
  for(let c=0;c<COLS;c++){
    let run=grid[0][c], s=0;
    for(let r=1;r<=ROWS;r++){
      const col=(r<ROWS)?grid[r][c]:-1;
      if(col!==run){
        const len=r-s; if(len>=3){ for(let k=s;k<r;k++) toClear.add(`${k},${c}`); }
        run=col; s=r;
      }
    }
  }
  const groups={};
  for(const key of toClear){
    const [r,c]=key.split(',').map(Number);
    const colId=grid[r][c];
    const name=NAME_BY_ID[colId];
    groups[name]=(groups[name]||0)+1;
  }
  return { set:toClear, groups };
}
async function resolveBoard(matches,chain){
  applyEN(matches.groups,chain);
  for(const key of matches.set){
    const [r,c]=key.split(',').map(Number);
    grid[r][c]=null;
  }
  renderAll(); collapse(); refill(); renderAll();
  const next=findMatches(); if(next.set.size>0){ await sleep(120); return resolveBoard(next,chain+1); }
}
function applyEN(groups,chain){
  for(const colorName in groups){
    const count=groups[colorName];
    const add=getGainAmount(colorName,count,chain);
    if(colorName in en){
      const need=getRequiredEN(colorName);
      en[colorName]=Math.min(need,en[colorName]+add);
    }
  }
  updateBars();
}
function collapse(){
  for(let c=0;c<COLS;c++){
    let w=ROWS-1;
    for(let r=ROWS-1;r>=0;r--){
      if(grid[r][c]!==null){
        if(w!==r){ grid[w][c]=grid[r][c]; grid[r][c]=null; }
        w--;
      }
    }
  }
}
function refill(){
  for(let c=0;c<COLS;c++){
    for(let r=0;r<ROWS;r++){
      if(grid[r][c]===null){ grid[r][c]=randColor(); }
    }
  }
}
function randColor(){ return Math.floor(Math.random()*4); }
function causesImmediateMatch(r,c,color){
  if(c>=2&&grid[r][c-1]===color&&grid[r][c-2]===color)return true;
  if(r>=2&&grid[r-1][c]===color&&grid[r-2][c]===color)return true;
  return false;
}

/* ====== スキル発動 ====== */
document.getElementById('btn-red').addEventListener('click', ()=> useSkill("RED"));
document.getElementById('btn-blue').addEventListener('click', ()=> useSkill("BLUE"));
document.getElementById('btn-yellow').addEventListener('click', ()=> useSkill("YELLOW"));
function useSkill(color){
  if(gameOver) return;
  const need=getRequiredEN(color); if(en[color]<need) return;
  const power=player.skills[color].power;
  const mult=rpsMul(enemy.attr,color);
  const dmg=Math.max(1,Math.round(power*mult));
  enemy.hp=Math.max(0,enemy.hp-dmg);
  updateHPBar();
  en[color]=0; updateBars();
  if(enemy.hp===0){ stopTimer(); showOverlay("VICTORY!"); gameOver=true; }
}

/* ====== ゲームオーバー＆リセット ====== */
function onGameOver(){
  gameOver=true;
  showOverlay("TIME UP!");
  setButtonEnabled('red',false); setButtonEnabled('blue',false); setButtonEnabled('yellow',false);
}
function showOverlay(text){ const o=document.getElementById('overlay'); o.textContent=text; o.style.display='flex'; }
function hideOverlay(){ document.getElementById('overlay').style.display='none'; }
document.getElementById('btn-reset').addEventListener('click', resetGame);

/* ====== 雑多 ====== */
function sleep(ms){ return new Promise(resolve => setTimeout(resolve, ms)); }
function resetGame(){
  enemy.hp = enemy.maxHP;
  gameOver=false; busy=false; firstPick=null; en={RED:0,BLUE:0,YELLOW:0};
  timeLeft=TIME_LIMIT_SECONDS;
  updateTimeBar();
  renderEnemyHeader(); updateHPBar(); renderPlayerLabels();
  initBoard(); renderAll(); updateBars();
  hideOverlay(); startTimer();
}

/* ====== 起動 ====== */
(function boot(){
  populateSelectors();
  const cfg = document.getElementById('cfgBox');
  if(window.matchMedia('(max-width: 420px)').matches) cfg.open = false;
  resetGame();
})();
</script>
</body>
</html>
